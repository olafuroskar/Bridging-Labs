// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings for `src/lsl_bindings.h`.
///
/// Regenerate bindings with `dart run ffigen --config ffigen.yaml`.
///
class LslBindingsBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  LslBindingsBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  LslBindingsBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Establish a new stream outlet. This makes the stream discoverable.
  /// @param info The stream information to use for creating this stream.
  /// Stays constant over the lifetime of the outlet.
  /// @note the outlet makes a copy of the streaminfo object upon construction (so the old info should
  /// still be destroyed.)
  /// @param chunk_size Optionally the desired chunk granularity (in samples) for transmission.
  /// If specified as 0, each push operation yields one chunk.
  /// Stream recipients can have this setting bypassed.
  /// @param max_buffered Optionally the maximum amount of data to buffer (in seconds if there is a
  /// nominal  sampling rate, otherwise x100 in samples). A good default is 360, which corresponds to 6
  /// minutes of data. Note that, for high-bandwidth data you will almost certainly want to use a lower
  /// value here to avoid  running out of RAM.
  /// @return A newly created lsl_outlet handle or NULL in the event that an error occurred.
  lsl_outlet lsl_create_outlet(
    lsl_streaminfo info,
    int chunk_size,
    int max_buffered,
  ) {
    return _lsl_create_outlet(
      info,
      chunk_size,
      max_buffered,
    );
  }

  late final _lsl_create_outletPtr = _lookup<
      ffi.NativeFunction<
          lsl_outlet Function(
              lsl_streaminfo, ffi.Int32, ffi.Int32)>>('lsl_create_outlet');
  late final _lsl_create_outlet = _lsl_create_outletPtr
      .asFunction<lsl_outlet Function(lsl_streaminfo, int, int)>();

  /// @copydoc lsl_create_outlet()
  /// @param flags An integer that is the result of bitwise OR'ing one or more options from
  /// #lsl_transport_options_t together (e.g., #transp_bufsize_samples|#transp_bufsize_thousandths)
  lsl_outlet lsl_create_outlet_ex(
    lsl_streaminfo info,
    int chunk_size,
    int max_buffered,
    lsl_transport_options_t flags,
  ) {
    return _lsl_create_outlet_ex(
      info,
      chunk_size,
      max_buffered,
      flags.value,
    );
  }

  late final _lsl_create_outlet_exPtr = _lookup<
      ffi.NativeFunction<
          lsl_outlet Function(lsl_streaminfo, ffi.Int32, ffi.Int32,
              ffi.UnsignedInt)>>('lsl_create_outlet_ex');
  late final _lsl_create_outlet_ex = _lsl_create_outlet_exPtr
      .asFunction<lsl_outlet Function(lsl_streaminfo, int, int, int)>();

  /// Destroy an outlet.
  /// The outlet will no longer be discoverable after destruction and all connected inlets will stop
  /// delivering data.
  void lsl_destroy_outlet(
    lsl_outlet out,
  ) {
    return _lsl_destroy_outlet(
      out,
    );
  }

  late final _lsl_destroy_outletPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(lsl_outlet)>>(
          'lsl_destroy_outlet');
  late final _lsl_destroy_outlet =
      _lsl_destroy_outletPtr.asFunction<void Function(lsl_outlet)>();

  /// Push a pointer to some values as a sample into the outlet.
  /// Handles type checking & conversion.
  /// @param out The lsl_outlet object through which to push the data.
  /// @param data A pointer to values to push. The number of values pointed to must be no less than the
  /// number of channels in the sample.
  /// #lsl_local_clock(); if omitted, the current time is used.
  /// @return Error code of the operation or lsl_no_error if successful (usually attributed to the
  /// wrong data type).
  /// @{
  int lsl_push_sample_f(
    lsl_outlet out,
    ffi.Pointer<ffi.Float> data,
  ) {
    return _lsl_push_sample_f(
      out,
      data,
    );
  }

  late final _lsl_push_sample_fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              lsl_outlet, ffi.Pointer<ffi.Float>)>>('lsl_push_sample_f');
  late final _lsl_push_sample_f = _lsl_push_sample_fPtr
      .asFunction<int Function(lsl_outlet, ffi.Pointer<ffi.Float>)>();

  int lsl_push_sample_d(
    lsl_outlet out,
    ffi.Pointer<ffi.Double> data,
  ) {
    return _lsl_push_sample_d(
      out,
      data,
    );
  }

  late final _lsl_push_sample_dPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              lsl_outlet, ffi.Pointer<ffi.Double>)>>('lsl_push_sample_d');
  late final _lsl_push_sample_d = _lsl_push_sample_dPtr
      .asFunction<int Function(lsl_outlet, ffi.Pointer<ffi.Double>)>();

  int lsl_push_sample_l(
    lsl_outlet out,
    ffi.Pointer<ffi.Int64> data,
  ) {
    return _lsl_push_sample_l(
      out,
      data,
    );
  }

  late final _lsl_push_sample_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              lsl_outlet, ffi.Pointer<ffi.Int64>)>>('lsl_push_sample_l');
  late final _lsl_push_sample_l = _lsl_push_sample_lPtr
      .asFunction<int Function(lsl_outlet, ffi.Pointer<ffi.Int64>)>();

  int lsl_push_sample_i(
    lsl_outlet out,
    ffi.Pointer<ffi.Int32> data,
  ) {
    return _lsl_push_sample_i(
      out,
      data,
    );
  }

  late final _lsl_push_sample_iPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              lsl_outlet, ffi.Pointer<ffi.Int32>)>>('lsl_push_sample_i');
  late final _lsl_push_sample_i = _lsl_push_sample_iPtr
      .asFunction<int Function(lsl_outlet, ffi.Pointer<ffi.Int32>)>();

  int lsl_push_sample_s(
    lsl_outlet out,
    ffi.Pointer<ffi.Int16> data,
  ) {
    return _lsl_push_sample_s(
      out,
      data,
    );
  }

  late final _lsl_push_sample_sPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              lsl_outlet, ffi.Pointer<ffi.Int16>)>>('lsl_push_sample_s');
  late final _lsl_push_sample_s = _lsl_push_sample_sPtr
      .asFunction<int Function(lsl_outlet, ffi.Pointer<ffi.Int16>)>();

  int lsl_push_sample_c(
    lsl_outlet out,
    ffi.Pointer<ffi.Char> data,
  ) {
    return _lsl_push_sample_c(
      out,
      data,
    );
  }

  late final _lsl_push_sample_cPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              lsl_outlet, ffi.Pointer<ffi.Char>)>>('lsl_push_sample_c');
  late final _lsl_push_sample_c = _lsl_push_sample_cPtr
      .asFunction<int Function(lsl_outlet, ffi.Pointer<ffi.Char>)>();

  int lsl_push_sample_str(
    lsl_outlet out,
    ffi.Pointer<ffi.Pointer<ffi.Char>> data,
  ) {
    return _lsl_push_sample_str(
      out,
      data,
    );
  }

  late final _lsl_push_sample_strPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(lsl_outlet,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('lsl_push_sample_str');
  late final _lsl_push_sample_str = _lsl_push_sample_strPtr.asFunction<
      int Function(lsl_outlet, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int lsl_push_sample_v(
    lsl_outlet out,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _lsl_push_sample_v(
      out,
      data,
    );
  }

  late final _lsl_push_sample_vPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              lsl_outlet, ffi.Pointer<ffi.Void>)>>('lsl_push_sample_v');
  late final _lsl_push_sample_v = _lsl_push_sample_vPtr
      .asFunction<int Function(lsl_outlet, ffi.Pointer<ffi.Void>)>();

  /// @}
  /// /** @copydoc lsl_push_sample_f
  ///  * @param timestamp Optionally the capture time of the sample, in agreement with
  ///  * @{
  ///  */
  int lsl_push_sample_ft(
    lsl_outlet out,
    ffi.Pointer<ffi.Float> data,
    double timestamp,
  ) {
    return _lsl_push_sample_ft(
      out,
      data,
      timestamp,
    );
  }

  late final _lsl_push_sample_ftPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(lsl_outlet, ffi.Pointer<ffi.Float>,
              ffi.Double)>>('lsl_push_sample_ft');
  late final _lsl_push_sample_ft = _lsl_push_sample_ftPtr
      .asFunction<int Function(lsl_outlet, ffi.Pointer<ffi.Float>, double)>();

  int lsl_push_sample_dt(
    lsl_outlet out,
    ffi.Pointer<ffi.Double> data,
    double timestamp,
  ) {
    return _lsl_push_sample_dt(
      out,
      data,
      timestamp,
    );
  }

  late final _lsl_push_sample_dtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(lsl_outlet, ffi.Pointer<ffi.Double>,
              ffi.Double)>>('lsl_push_sample_dt');
  late final _lsl_push_sample_dt = _lsl_push_sample_dtPtr
      .asFunction<int Function(lsl_outlet, ffi.Pointer<ffi.Double>, double)>();

  int lsl_push_sample_lt(
    lsl_outlet out,
    ffi.Pointer<ffi.Int64> data,
    double timestamp,
  ) {
    return _lsl_push_sample_lt(
      out,
      data,
      timestamp,
    );
  }

  late final _lsl_push_sample_ltPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(lsl_outlet, ffi.Pointer<ffi.Int64>,
              ffi.Double)>>('lsl_push_sample_lt');
  late final _lsl_push_sample_lt = _lsl_push_sample_ltPtr
      .asFunction<int Function(lsl_outlet, ffi.Pointer<ffi.Int64>, double)>();

  int lsl_push_sample_it(
    lsl_outlet out,
    ffi.Pointer<ffi.Int32> data,
    double timestamp,
  ) {
    return _lsl_push_sample_it(
      out,
      data,
      timestamp,
    );
  }

  late final _lsl_push_sample_itPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(lsl_outlet, ffi.Pointer<ffi.Int32>,
              ffi.Double)>>('lsl_push_sample_it');
  late final _lsl_push_sample_it = _lsl_push_sample_itPtr
      .asFunction<int Function(lsl_outlet, ffi.Pointer<ffi.Int32>, double)>();

  int lsl_push_sample_st(
    lsl_outlet out,
    ffi.Pointer<ffi.Int16> data,
    double timestamp,
  ) {
    return _lsl_push_sample_st(
      out,
      data,
      timestamp,
    );
  }

  late final _lsl_push_sample_stPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(lsl_outlet, ffi.Pointer<ffi.Int16>,
              ffi.Double)>>('lsl_push_sample_st');
  late final _lsl_push_sample_st = _lsl_push_sample_stPtr
      .asFunction<int Function(lsl_outlet, ffi.Pointer<ffi.Int16>, double)>();

  int lsl_push_sample_ct(
    lsl_outlet out,
    ffi.Pointer<ffi.Char> data,
    double timestamp,
  ) {
    return _lsl_push_sample_ct(
      out,
      data,
      timestamp,
    );
  }

  late final _lsl_push_sample_ctPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(lsl_outlet, ffi.Pointer<ffi.Char>,
              ffi.Double)>>('lsl_push_sample_ct');
  late final _lsl_push_sample_ct = _lsl_push_sample_ctPtr
      .asFunction<int Function(lsl_outlet, ffi.Pointer<ffi.Char>, double)>();

  int lsl_push_sample_strt(
    lsl_outlet out,
    ffi.Pointer<ffi.Pointer<ffi.Char>> data,
    double timestamp,
  ) {
    return _lsl_push_sample_strt(
      out,
      data,
      timestamp,
    );
  }

  late final _lsl_push_sample_strtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(lsl_outlet, ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Double)>>('lsl_push_sample_strt');
  late final _lsl_push_sample_strt = _lsl_push_sample_strtPtr.asFunction<
      int Function(lsl_outlet, ffi.Pointer<ffi.Pointer<ffi.Char>>, double)>();

  int lsl_push_sample_vt(
    lsl_outlet out,
    ffi.Pointer<ffi.Void> data,
    double timestamp,
  ) {
    return _lsl_push_sample_vt(
      out,
      data,
      timestamp,
    );
  }

  late final _lsl_push_sample_vtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(lsl_outlet, ffi.Pointer<ffi.Void>,
              ffi.Double)>>('lsl_push_sample_vt');
  late final _lsl_push_sample_vt = _lsl_push_sample_vtPtr
      .asFunction<int Function(lsl_outlet, ffi.Pointer<ffi.Void>, double)>();

  /// @}
  /// /** @copydoc lsl_push_sample_ft
  ///  * @param pushthrough Whether to push the sample through to the receivers instead of buffering it
  ///  * with subsequent samples. Note that the chunk_size, if specified at outlet construction, takes
  ///  * precedence over the pushthrough flag.
  ///  * @{
  ///  */
  int lsl_push_sample_ftp(
    lsl_outlet out,
    ffi.Pointer<ffi.Float> data,
    double timestamp,
    int pushthrough,
  ) {
    return _lsl_push_sample_ftp(
      out,
      data,
      timestamp,
      pushthrough,
    );
  }

  late final _lsl_push_sample_ftpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(lsl_outlet, ffi.Pointer<ffi.Float>, ffi.Double,
              ffi.Int32)>>('lsl_push_sample_ftp');
  late final _lsl_push_sample_ftp = _lsl_push_sample_ftpPtr.asFunction<
      int Function(lsl_outlet, ffi.Pointer<ffi.Float>, double, int)>();

  int lsl_push_sample_dtp(
    lsl_outlet out,
    ffi.Pointer<ffi.Double> data,
    double timestamp,
    int pushthrough,
  ) {
    return _lsl_push_sample_dtp(
      out,
      data,
      timestamp,
      pushthrough,
    );
  }

  late final _lsl_push_sample_dtpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(lsl_outlet, ffi.Pointer<ffi.Double>, ffi.Double,
              ffi.Int32)>>('lsl_push_sample_dtp');
  late final _lsl_push_sample_dtp = _lsl_push_sample_dtpPtr.asFunction<
      int Function(lsl_outlet, ffi.Pointer<ffi.Double>, double, int)>();

  int lsl_push_sample_ltp(
    lsl_outlet out,
    ffi.Pointer<ffi.Int64> data,
    double timestamp,
    int pushthrough,
  ) {
    return _lsl_push_sample_ltp(
      out,
      data,
      timestamp,
      pushthrough,
    );
  }

  late final _lsl_push_sample_ltpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(lsl_outlet, ffi.Pointer<ffi.Int64>, ffi.Double,
              ffi.Int32)>>('lsl_push_sample_ltp');
  late final _lsl_push_sample_ltp = _lsl_push_sample_ltpPtr.asFunction<
      int Function(lsl_outlet, ffi.Pointer<ffi.Int64>, double, int)>();

  int lsl_push_sample_itp(
    lsl_outlet out,
    ffi.Pointer<ffi.Int32> data,
    double timestamp,
    int pushthrough,
  ) {
    return _lsl_push_sample_itp(
      out,
      data,
      timestamp,
      pushthrough,
    );
  }

  late final _lsl_push_sample_itpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(lsl_outlet, ffi.Pointer<ffi.Int32>, ffi.Double,
              ffi.Int32)>>('lsl_push_sample_itp');
  late final _lsl_push_sample_itp = _lsl_push_sample_itpPtr.asFunction<
      int Function(lsl_outlet, ffi.Pointer<ffi.Int32>, double, int)>();

  int lsl_push_sample_stp(
    lsl_outlet out,
    ffi.Pointer<ffi.Int16> data,
    double timestamp,
    int pushthrough,
  ) {
    return _lsl_push_sample_stp(
      out,
      data,
      timestamp,
      pushthrough,
    );
  }

  late final _lsl_push_sample_stpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(lsl_outlet, ffi.Pointer<ffi.Int16>, ffi.Double,
              ffi.Int32)>>('lsl_push_sample_stp');
  late final _lsl_push_sample_stp = _lsl_push_sample_stpPtr.asFunction<
      int Function(lsl_outlet, ffi.Pointer<ffi.Int16>, double, int)>();

  int lsl_push_sample_ctp(
    lsl_outlet out,
    ffi.Pointer<ffi.Char> data,
    double timestamp,
    int pushthrough,
  ) {
    return _lsl_push_sample_ctp(
      out,
      data,
      timestamp,
      pushthrough,
    );
  }

  late final _lsl_push_sample_ctpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(lsl_outlet, ffi.Pointer<ffi.Char>, ffi.Double,
              ffi.Int32)>>('lsl_push_sample_ctp');
  late final _lsl_push_sample_ctp = _lsl_push_sample_ctpPtr.asFunction<
      int Function(lsl_outlet, ffi.Pointer<ffi.Char>, double, int)>();

  int lsl_push_sample_strtp(
    lsl_outlet out,
    ffi.Pointer<ffi.Pointer<ffi.Char>> data,
    double timestamp,
    int pushthrough,
  ) {
    return _lsl_push_sample_strtp(
      out,
      data,
      timestamp,
      pushthrough,
    );
  }

  late final _lsl_push_sample_strtpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(lsl_outlet, ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Double, ffi.Int32)>>('lsl_push_sample_strtp');
  late final _lsl_push_sample_strtp = _lsl_push_sample_strtpPtr.asFunction<
      int Function(
          lsl_outlet, ffi.Pointer<ffi.Pointer<ffi.Char>>, double, int)>();

  int lsl_push_sample_vtp(
    lsl_outlet out,
    ffi.Pointer<ffi.Void> data,
    double timestamp,
    int pushthrough,
  ) {
    return _lsl_push_sample_vtp(
      out,
      data,
      timestamp,
      pushthrough,
    );
  }

  late final _lsl_push_sample_vtpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(lsl_outlet, ffi.Pointer<ffi.Void>, ffi.Double,
              ffi.Int32)>>('lsl_push_sample_vtp');
  late final _lsl_push_sample_vtp = _lsl_push_sample_vtpPtr.asFunction<
      int Function(lsl_outlet, ffi.Pointer<ffi.Void>, double, int)>();

  /// @copybrief lsl_push_sample_ftp
  /// @see lsl_push_sample_ftp
  /// @param out The lsl_outlet object through which to push the data.
  /// @param data A pointer to values to push. The number of values pointed to must be no less than the
  /// number of channels in the sample.
  /// @param lengths A pointer the number of elements to push for each channel (string lengths).
  int lsl_push_sample_buf(
    lsl_outlet out,
    ffi.Pointer<ffi.Pointer<ffi.Char>> data,
    ffi.Pointer<ffi.Uint32> lengths,
  ) {
    return _lsl_push_sample_buf(
      out,
      data,
      lengths,
    );
  }

  late final _lsl_push_sample_bufPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(lsl_outlet, ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Uint32>)>>('lsl_push_sample_buf');
  late final _lsl_push_sample_buf = _lsl_push_sample_bufPtr.asFunction<
      int Function(lsl_outlet, ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Uint32>)>();

  /// @copydoc lsl_push_sample_buf
  /// @param timestamp @see lsl_push_sample_ftp
  int lsl_push_sample_buft(
    lsl_outlet out,
    ffi.Pointer<ffi.Pointer<ffi.Char>> data,
    ffi.Pointer<ffi.Uint32> lengths,
    double timestamp,
  ) {
    return _lsl_push_sample_buft(
      out,
      data,
      lengths,
      timestamp,
    );
  }

  late final _lsl_push_sample_buftPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(lsl_outlet, ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Uint32>, ffi.Double)>>('lsl_push_sample_buft');
  late final _lsl_push_sample_buft = _lsl_push_sample_buftPtr.asFunction<
      int Function(lsl_outlet, ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Uint32>, double)>();

  /// @copydoc lsl_push_sample_buft
  /// @param pushthrough @see lsl_push_sample_ftp
  int lsl_push_sample_buftp(
    lsl_outlet out,
    ffi.Pointer<ffi.Pointer<ffi.Char>> data,
    ffi.Pointer<ffi.Uint32> lengths,
    double timestamp,
    int pushthrough,
  ) {
    return _lsl_push_sample_buftp(
      out,
      data,
      lengths,
      timestamp,
      pushthrough,
    );
  }

  late final _lsl_push_sample_buftpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              lsl_outlet,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Uint32>,
              ffi.Double,
              ffi.Int32)>>('lsl_push_sample_buftp');
  late final _lsl_push_sample_buftp = _lsl_push_sample_buftpPtr.asFunction<
      int Function(lsl_outlet, ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Uint32>, double, int)>();

  /// Push a chunk of multiplexed samples into the outlet. One timestamp per sample is provided.
  ///
  /// @attention Note that the provided buffer size is measured in channel values (e.g. floats) rather
  /// than in samples.
  ///
  /// Handles type checking & conversion.
  /// @param out The lsl_outlet object through which to push the data.
  /// @param data A buffer of channel values holding the data for zero or more successive samples to
  /// send.
  /// @param data_elements The number of data values (of type T) in the data buffer. Must be a multiple
  /// of the channel count.
  /// @return Error code of the operation (usually attributed to the wrong data type).
  /// @{
  int lsl_push_chunk_f(
    lsl_outlet out,
    ffi.Pointer<ffi.Float> data,
    int data_elements,
  ) {
    return _lsl_push_chunk_f(
      out,
      data,
      data_elements,
    );
  }

  late final _lsl_push_chunk_fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(lsl_outlet, ffi.Pointer<ffi.Float>,
              ffi.UnsignedLong)>>('lsl_push_chunk_f');
  late final _lsl_push_chunk_f = _lsl_push_chunk_fPtr
      .asFunction<int Function(lsl_outlet, ffi.Pointer<ffi.Float>, int)>();

  int lsl_push_chunk_d(
    lsl_outlet out,
    ffi.Pointer<ffi.Double> data,
    int data_elements,
  ) {
    return _lsl_push_chunk_d(
      out,
      data,
      data_elements,
    );
  }

  late final _lsl_push_chunk_dPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(lsl_outlet, ffi.Pointer<ffi.Double>,
              ffi.UnsignedLong)>>('lsl_push_chunk_d');
  late final _lsl_push_chunk_d = _lsl_push_chunk_dPtr
      .asFunction<int Function(lsl_outlet, ffi.Pointer<ffi.Double>, int)>();

  int lsl_push_chunk_l(
    lsl_outlet out,
    ffi.Pointer<ffi.Int64> data,
    int data_elements,
  ) {
    return _lsl_push_chunk_l(
      out,
      data,
      data_elements,
    );
  }

  late final _lsl_push_chunk_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(lsl_outlet, ffi.Pointer<ffi.Int64>,
              ffi.UnsignedLong)>>('lsl_push_chunk_l');
  late final _lsl_push_chunk_l = _lsl_push_chunk_lPtr
      .asFunction<int Function(lsl_outlet, ffi.Pointer<ffi.Int64>, int)>();

  int lsl_push_chunk_i(
    lsl_outlet out,
    ffi.Pointer<ffi.Int32> data,
    int data_elements,
  ) {
    return _lsl_push_chunk_i(
      out,
      data,
      data_elements,
    );
  }

  late final _lsl_push_chunk_iPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(lsl_outlet, ffi.Pointer<ffi.Int32>,
              ffi.UnsignedLong)>>('lsl_push_chunk_i');
  late final _lsl_push_chunk_i = _lsl_push_chunk_iPtr
      .asFunction<int Function(lsl_outlet, ffi.Pointer<ffi.Int32>, int)>();

  int lsl_push_chunk_s(
    lsl_outlet out,
    ffi.Pointer<ffi.Int16> data,
    int data_elements,
  ) {
    return _lsl_push_chunk_s(
      out,
      data,
      data_elements,
    );
  }

  late final _lsl_push_chunk_sPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(lsl_outlet, ffi.Pointer<ffi.Int16>,
              ffi.UnsignedLong)>>('lsl_push_chunk_s');
  late final _lsl_push_chunk_s = _lsl_push_chunk_sPtr
      .asFunction<int Function(lsl_outlet, ffi.Pointer<ffi.Int16>, int)>();

  int lsl_push_chunk_c(
    lsl_outlet out,
    ffi.Pointer<ffi.Char> data,
    int data_elements,
  ) {
    return _lsl_push_chunk_c(
      out,
      data,
      data_elements,
    );
  }

  late final _lsl_push_chunk_cPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(lsl_outlet, ffi.Pointer<ffi.Char>,
              ffi.UnsignedLong)>>('lsl_push_chunk_c');
  late final _lsl_push_chunk_c = _lsl_push_chunk_cPtr
      .asFunction<int Function(lsl_outlet, ffi.Pointer<ffi.Char>, int)>();

  int lsl_push_chunk_str(
    lsl_outlet out,
    ffi.Pointer<ffi.Pointer<ffi.Char>> data,
    int data_elements,
  ) {
    return _lsl_push_chunk_str(
      out,
      data,
      data_elements,
    );
  }

  late final _lsl_push_chunk_strPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(lsl_outlet, ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.UnsignedLong)>>('lsl_push_chunk_str');
  late final _lsl_push_chunk_str = _lsl_push_chunk_strPtr.asFunction<
      int Function(lsl_outlet, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  /// @copydoc lsl_push_chunk_f
  /// @param timestamp Optionally the capture time of the most recent sample, in agreement with
  /// lsl_local_clock(); if omitted, the current time is used.
  /// The time stamps of other samples are automatically derived based on the sampling rate of the
  /// stream.
  /// @{
  int lsl_push_chunk_ft(
    lsl_outlet out,
    ffi.Pointer<ffi.Float> data,
    int data_elements,
    double timestamp,
  ) {
    return _lsl_push_chunk_ft(
      out,
      data,
      data_elements,
      timestamp,
    );
  }

  late final _lsl_push_chunk_ftPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(lsl_outlet, ffi.Pointer<ffi.Float>,
              ffi.UnsignedLong, ffi.Double)>>('lsl_push_chunk_ft');
  late final _lsl_push_chunk_ft = _lsl_push_chunk_ftPtr.asFunction<
      int Function(lsl_outlet, ffi.Pointer<ffi.Float>, int, double)>();

  int lsl_push_chunk_dt(
    lsl_outlet out,
    ffi.Pointer<ffi.Double> data,
    int data_elements,
    double timestamp,
  ) {
    return _lsl_push_chunk_dt(
      out,
      data,
      data_elements,
      timestamp,
    );
  }

  late final _lsl_push_chunk_dtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(lsl_outlet, ffi.Pointer<ffi.Double>,
              ffi.UnsignedLong, ffi.Double)>>('lsl_push_chunk_dt');
  late final _lsl_push_chunk_dt = _lsl_push_chunk_dtPtr.asFunction<
      int Function(lsl_outlet, ffi.Pointer<ffi.Double>, int, double)>();

  int lsl_push_chunk_lt(
    lsl_outlet out,
    ffi.Pointer<ffi.Int64> data,
    int data_elements,
    double timestamp,
  ) {
    return _lsl_push_chunk_lt(
      out,
      data,
      data_elements,
      timestamp,
    );
  }

  late final _lsl_push_chunk_ltPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(lsl_outlet, ffi.Pointer<ffi.Int64>,
              ffi.UnsignedLong, ffi.Double)>>('lsl_push_chunk_lt');
  late final _lsl_push_chunk_lt = _lsl_push_chunk_ltPtr.asFunction<
      int Function(lsl_outlet, ffi.Pointer<ffi.Int64>, int, double)>();

  int lsl_push_chunk_it(
    lsl_outlet out,
    ffi.Pointer<ffi.Int32> data,
    int data_elements,
    double timestamp,
  ) {
    return _lsl_push_chunk_it(
      out,
      data,
      data_elements,
      timestamp,
    );
  }

  late final _lsl_push_chunk_itPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(lsl_outlet, ffi.Pointer<ffi.Int32>,
              ffi.UnsignedLong, ffi.Double)>>('lsl_push_chunk_it');
  late final _lsl_push_chunk_it = _lsl_push_chunk_itPtr.asFunction<
      int Function(lsl_outlet, ffi.Pointer<ffi.Int32>, int, double)>();

  int lsl_push_chunk_st(
    lsl_outlet out,
    ffi.Pointer<ffi.Int16> data,
    int data_elements,
    double timestamp,
  ) {
    return _lsl_push_chunk_st(
      out,
      data,
      data_elements,
      timestamp,
    );
  }

  late final _lsl_push_chunk_stPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(lsl_outlet, ffi.Pointer<ffi.Int16>,
              ffi.UnsignedLong, ffi.Double)>>('lsl_push_chunk_st');
  late final _lsl_push_chunk_st = _lsl_push_chunk_stPtr.asFunction<
      int Function(lsl_outlet, ffi.Pointer<ffi.Int16>, int, double)>();

  int lsl_push_chunk_ct(
    lsl_outlet out,
    ffi.Pointer<ffi.Char> data,
    int data_elements,
    double timestamp,
  ) {
    return _lsl_push_chunk_ct(
      out,
      data,
      data_elements,
      timestamp,
    );
  }

  late final _lsl_push_chunk_ctPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(lsl_outlet, ffi.Pointer<ffi.Char>,
              ffi.UnsignedLong, ffi.Double)>>('lsl_push_chunk_ct');
  late final _lsl_push_chunk_ct = _lsl_push_chunk_ctPtr.asFunction<
      int Function(lsl_outlet, ffi.Pointer<ffi.Char>, int, double)>();

  int lsl_push_chunk_strt(
    lsl_outlet out,
    ffi.Pointer<ffi.Pointer<ffi.Char>> data,
    int data_elements,
    double timestamp,
  ) {
    return _lsl_push_chunk_strt(
      out,
      data,
      data_elements,
      timestamp,
    );
  }

  late final _lsl_push_chunk_strtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(lsl_outlet, ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.UnsignedLong, ffi.Double)>>('lsl_push_chunk_strt');
  late final _lsl_push_chunk_strt = _lsl_push_chunk_strtPtr.asFunction<
      int Function(
          lsl_outlet, ffi.Pointer<ffi.Pointer<ffi.Char>>, int, double)>();

  /// @copydoc lsl_push_chunk_ft
  /// @param pushthrough Whether to push the chunk through to the receivers instead of buffering it
  /// with subsequent samples. Note that the chunk_size, if specified at outlet construction, takes
  /// precedence over the pushthrough flag.
  /// @{
  int lsl_push_chunk_ftp(
    lsl_outlet out,
    ffi.Pointer<ffi.Float> data,
    int data_elements,
    double timestamp,
    int pushthrough,
  ) {
    return _lsl_push_chunk_ftp(
      out,
      data,
      data_elements,
      timestamp,
      pushthrough,
    );
  }

  late final _lsl_push_chunk_ftpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(lsl_outlet, ffi.Pointer<ffi.Float>,
              ffi.UnsignedLong, ffi.Double, ffi.Int32)>>('lsl_push_chunk_ftp');
  late final _lsl_push_chunk_ftp = _lsl_push_chunk_ftpPtr.asFunction<
      int Function(lsl_outlet, ffi.Pointer<ffi.Float>, int, double, int)>();

  int lsl_push_chunk_dtp(
    lsl_outlet out,
    ffi.Pointer<ffi.Double> data,
    int data_elements,
    double timestamp,
    int pushthrough,
  ) {
    return _lsl_push_chunk_dtp(
      out,
      data,
      data_elements,
      timestamp,
      pushthrough,
    );
  }

  late final _lsl_push_chunk_dtpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(lsl_outlet, ffi.Pointer<ffi.Double>,
              ffi.UnsignedLong, ffi.Double, ffi.Int32)>>('lsl_push_chunk_dtp');
  late final _lsl_push_chunk_dtp = _lsl_push_chunk_dtpPtr.asFunction<
      int Function(lsl_outlet, ffi.Pointer<ffi.Double>, int, double, int)>();

  int lsl_push_chunk_ltp(
    lsl_outlet out,
    ffi.Pointer<ffi.Int64> data,
    int data_elements,
    double timestamp,
    int pushthrough,
  ) {
    return _lsl_push_chunk_ltp(
      out,
      data,
      data_elements,
      timestamp,
      pushthrough,
    );
  }

  late final _lsl_push_chunk_ltpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(lsl_outlet, ffi.Pointer<ffi.Int64>,
              ffi.UnsignedLong, ffi.Double, ffi.Int32)>>('lsl_push_chunk_ltp');
  late final _lsl_push_chunk_ltp = _lsl_push_chunk_ltpPtr.asFunction<
      int Function(lsl_outlet, ffi.Pointer<ffi.Int64>, int, double, int)>();

  int lsl_push_chunk_itp(
    lsl_outlet out,
    ffi.Pointer<ffi.Int32> data,
    int data_elements,
    double timestamp,
    int pushthrough,
  ) {
    return _lsl_push_chunk_itp(
      out,
      data,
      data_elements,
      timestamp,
      pushthrough,
    );
  }

  late final _lsl_push_chunk_itpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(lsl_outlet, ffi.Pointer<ffi.Int32>,
              ffi.UnsignedLong, ffi.Double, ffi.Int32)>>('lsl_push_chunk_itp');
  late final _lsl_push_chunk_itp = _lsl_push_chunk_itpPtr.asFunction<
      int Function(lsl_outlet, ffi.Pointer<ffi.Int32>, int, double, int)>();

  int lsl_push_chunk_stp(
    lsl_outlet out,
    ffi.Pointer<ffi.Int16> data,
    int data_elements,
    double timestamp,
    int pushthrough,
  ) {
    return _lsl_push_chunk_stp(
      out,
      data,
      data_elements,
      timestamp,
      pushthrough,
    );
  }

  late final _lsl_push_chunk_stpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(lsl_outlet, ffi.Pointer<ffi.Int16>,
              ffi.UnsignedLong, ffi.Double, ffi.Int32)>>('lsl_push_chunk_stp');
  late final _lsl_push_chunk_stp = _lsl_push_chunk_stpPtr.asFunction<
      int Function(lsl_outlet, ffi.Pointer<ffi.Int16>, int, double, int)>();

  int lsl_push_chunk_ctp(
    lsl_outlet out,
    ffi.Pointer<ffi.Char> data,
    int data_elements,
    double timestamp,
    int pushthrough,
  ) {
    return _lsl_push_chunk_ctp(
      out,
      data,
      data_elements,
      timestamp,
      pushthrough,
    );
  }

  late final _lsl_push_chunk_ctpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(lsl_outlet, ffi.Pointer<ffi.Char>,
              ffi.UnsignedLong, ffi.Double, ffi.Int32)>>('lsl_push_chunk_ctp');
  late final _lsl_push_chunk_ctp = _lsl_push_chunk_ctpPtr.asFunction<
      int Function(lsl_outlet, ffi.Pointer<ffi.Char>, int, double, int)>();

  int lsl_push_chunk_strtp(
    lsl_outlet out,
    ffi.Pointer<ffi.Pointer<ffi.Char>> data,
    int data_elements,
    double timestamp,
    int pushthrough,
  ) {
    return _lsl_push_chunk_strtp(
      out,
      data,
      data_elements,
      timestamp,
      pushthrough,
    );
  }

  late final _lsl_push_chunk_strtpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              lsl_outlet,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.UnsignedLong,
              ffi.Double,
              ffi.Int32)>>('lsl_push_chunk_strtp');
  late final _lsl_push_chunk_strtp = _lsl_push_chunk_strtpPtr.asFunction<
      int Function(
          lsl_outlet, ffi.Pointer<ffi.Pointer<ffi.Char>>, int, double, int)>();

  /// @}
  /// /** @copydoc lsl_push_chunk_f
  ///  * @param timestamps Buffer holding one time stamp for each sample in the data buffer.
  ///  * @{
  ///  */
  int lsl_push_chunk_ftn(
    lsl_outlet out,
    ffi.Pointer<ffi.Float> data,
    int data_elements,
    ffi.Pointer<ffi.Double> timestamps,
  ) {
    return _lsl_push_chunk_ftn(
      out,
      data,
      data_elements,
      timestamps,
    );
  }

  late final _lsl_push_chunk_ftnPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              lsl_outlet,
              ffi.Pointer<ffi.Float>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.Double>)>>('lsl_push_chunk_ftn');
  late final _lsl_push_chunk_ftn = _lsl_push_chunk_ftnPtr.asFunction<
      int Function(
          lsl_outlet, ffi.Pointer<ffi.Float>, int, ffi.Pointer<ffi.Double>)>();

  int lsl_push_chunk_dtn(
    lsl_outlet out,
    ffi.Pointer<ffi.Double> data,
    int data_elements,
    ffi.Pointer<ffi.Double> timestamps,
  ) {
    return _lsl_push_chunk_dtn(
      out,
      data,
      data_elements,
      timestamps,
    );
  }

  late final _lsl_push_chunk_dtnPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              lsl_outlet,
              ffi.Pointer<ffi.Double>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.Double>)>>('lsl_push_chunk_dtn');
  late final _lsl_push_chunk_dtn = _lsl_push_chunk_dtnPtr.asFunction<
      int Function(
          lsl_outlet, ffi.Pointer<ffi.Double>, int, ffi.Pointer<ffi.Double>)>();

  int lsl_push_chunk_ltn(
    lsl_outlet out,
    ffi.Pointer<ffi.Int64> data,
    int data_elements,
    ffi.Pointer<ffi.Double> timestamps,
  ) {
    return _lsl_push_chunk_ltn(
      out,
      data,
      data_elements,
      timestamps,
    );
  }

  late final _lsl_push_chunk_ltnPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              lsl_outlet,
              ffi.Pointer<ffi.Int64>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.Double>)>>('lsl_push_chunk_ltn');
  late final _lsl_push_chunk_ltn = _lsl_push_chunk_ltnPtr.asFunction<
      int Function(
          lsl_outlet, ffi.Pointer<ffi.Int64>, int, ffi.Pointer<ffi.Double>)>();

  int lsl_push_chunk_itn(
    lsl_outlet out,
    ffi.Pointer<ffi.Int32> data,
    int data_elements,
    ffi.Pointer<ffi.Double> timestamps,
  ) {
    return _lsl_push_chunk_itn(
      out,
      data,
      data_elements,
      timestamps,
    );
  }

  late final _lsl_push_chunk_itnPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              lsl_outlet,
              ffi.Pointer<ffi.Int32>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.Double>)>>('lsl_push_chunk_itn');
  late final _lsl_push_chunk_itn = _lsl_push_chunk_itnPtr.asFunction<
      int Function(
          lsl_outlet, ffi.Pointer<ffi.Int32>, int, ffi.Pointer<ffi.Double>)>();

  int lsl_push_chunk_stn(
    lsl_outlet out,
    ffi.Pointer<ffi.Int16> data,
    int data_elements,
    ffi.Pointer<ffi.Double> timestamps,
  ) {
    return _lsl_push_chunk_stn(
      out,
      data,
      data_elements,
      timestamps,
    );
  }

  late final _lsl_push_chunk_stnPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              lsl_outlet,
              ffi.Pointer<ffi.Int16>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.Double>)>>('lsl_push_chunk_stn');
  late final _lsl_push_chunk_stn = _lsl_push_chunk_stnPtr.asFunction<
      int Function(
          lsl_outlet, ffi.Pointer<ffi.Int16>, int, ffi.Pointer<ffi.Double>)>();

  int lsl_push_chunk_ctn(
    lsl_outlet out,
    ffi.Pointer<ffi.Char> data,
    int data_elements,
    ffi.Pointer<ffi.Double> timestamps,
  ) {
    return _lsl_push_chunk_ctn(
      out,
      data,
      data_elements,
      timestamps,
    );
  }

  late final _lsl_push_chunk_ctnPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              lsl_outlet,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.Double>)>>('lsl_push_chunk_ctn');
  late final _lsl_push_chunk_ctn = _lsl_push_chunk_ctnPtr.asFunction<
      int Function(
          lsl_outlet, ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Double>)>();

  int lsl_push_chunk_strtn(
    lsl_outlet out,
    ffi.Pointer<ffi.Pointer<ffi.Char>> data,
    int data_elements,
    ffi.Pointer<ffi.Double> timestamps,
  ) {
    return _lsl_push_chunk_strtn(
      out,
      data,
      data_elements,
      timestamps,
    );
  }

  late final _lsl_push_chunk_strtnPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              lsl_outlet,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.Double>)>>('lsl_push_chunk_strtn');
  late final _lsl_push_chunk_strtn = _lsl_push_chunk_strtnPtr.asFunction<
      int Function(lsl_outlet, ffi.Pointer<ffi.Pointer<ffi.Char>>, int,
          ffi.Pointer<ffi.Double>)>();

  /// @copydoc lsl_push_chunk_ftn
  /// @param pushthrough Whether to push the chunk through to the receivers instead of buffering it
  /// with subsequent samples. Note that the chunk_size, if specified at outlet construction, takes
  /// precedence over the pushthrough flag.
  /// @{
  int lsl_push_chunk_ftnp(
    lsl_outlet out,
    ffi.Pointer<ffi.Float> data,
    int data_elements,
    ffi.Pointer<ffi.Double> timestamps,
    int pushthrough,
  ) {
    return _lsl_push_chunk_ftnp(
      out,
      data,
      data_elements,
      timestamps,
      pushthrough,
    );
  }

  late final _lsl_push_chunk_ftnpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              lsl_outlet,
              ffi.Pointer<ffi.Float>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.Double>,
              ffi.Int32)>>('lsl_push_chunk_ftnp');
  late final _lsl_push_chunk_ftnp = _lsl_push_chunk_ftnpPtr.asFunction<
      int Function(lsl_outlet, ffi.Pointer<ffi.Float>, int,
          ffi.Pointer<ffi.Double>, int)>();

  int lsl_push_chunk_dtnp(
    lsl_outlet out,
    ffi.Pointer<ffi.Double> data,
    int data_elements,
    ffi.Pointer<ffi.Double> timestamps,
    int pushthrough,
  ) {
    return _lsl_push_chunk_dtnp(
      out,
      data,
      data_elements,
      timestamps,
      pushthrough,
    );
  }

  late final _lsl_push_chunk_dtnpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              lsl_outlet,
              ffi.Pointer<ffi.Double>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.Double>,
              ffi.Int32)>>('lsl_push_chunk_dtnp');
  late final _lsl_push_chunk_dtnp = _lsl_push_chunk_dtnpPtr.asFunction<
      int Function(lsl_outlet, ffi.Pointer<ffi.Double>, int,
          ffi.Pointer<ffi.Double>, int)>();

  int lsl_push_chunk_ltnp(
    lsl_outlet out,
    ffi.Pointer<ffi.Int64> data,
    int data_elements,
    ffi.Pointer<ffi.Double> timestamps,
    int pushthrough,
  ) {
    return _lsl_push_chunk_ltnp(
      out,
      data,
      data_elements,
      timestamps,
      pushthrough,
    );
  }

  late final _lsl_push_chunk_ltnpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              lsl_outlet,
              ffi.Pointer<ffi.Int64>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.Double>,
              ffi.Int32)>>('lsl_push_chunk_ltnp');
  late final _lsl_push_chunk_ltnp = _lsl_push_chunk_ltnpPtr.asFunction<
      int Function(lsl_outlet, ffi.Pointer<ffi.Int64>, int,
          ffi.Pointer<ffi.Double>, int)>();

  int lsl_push_chunk_itnp(
    lsl_outlet out,
    ffi.Pointer<ffi.Int32> data,
    int data_elements,
    ffi.Pointer<ffi.Double> timestamps,
    int pushthrough,
  ) {
    return _lsl_push_chunk_itnp(
      out,
      data,
      data_elements,
      timestamps,
      pushthrough,
    );
  }

  late final _lsl_push_chunk_itnpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              lsl_outlet,
              ffi.Pointer<ffi.Int32>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.Double>,
              ffi.Int32)>>('lsl_push_chunk_itnp');
  late final _lsl_push_chunk_itnp = _lsl_push_chunk_itnpPtr.asFunction<
      int Function(lsl_outlet, ffi.Pointer<ffi.Int32>, int,
          ffi.Pointer<ffi.Double>, int)>();

  int lsl_push_chunk_stnp(
    lsl_outlet out,
    ffi.Pointer<ffi.Int16> data,
    int data_elements,
    ffi.Pointer<ffi.Double> timestamps,
    int pushthrough,
  ) {
    return _lsl_push_chunk_stnp(
      out,
      data,
      data_elements,
      timestamps,
      pushthrough,
    );
  }

  late final _lsl_push_chunk_stnpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              lsl_outlet,
              ffi.Pointer<ffi.Int16>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.Double>,
              ffi.Int32)>>('lsl_push_chunk_stnp');
  late final _lsl_push_chunk_stnp = _lsl_push_chunk_stnpPtr.asFunction<
      int Function(lsl_outlet, ffi.Pointer<ffi.Int16>, int,
          ffi.Pointer<ffi.Double>, int)>();

  int lsl_push_chunk_ctnp(
    lsl_outlet out,
    ffi.Pointer<ffi.Char> data,
    int data_elements,
    ffi.Pointer<ffi.Double> timestamps,
    int pushthrough,
  ) {
    return _lsl_push_chunk_ctnp(
      out,
      data,
      data_elements,
      timestamps,
      pushthrough,
    );
  }

  late final _lsl_push_chunk_ctnpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              lsl_outlet,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.Double>,
              ffi.Int32)>>('lsl_push_chunk_ctnp');
  late final _lsl_push_chunk_ctnp = _lsl_push_chunk_ctnpPtr.asFunction<
      int Function(lsl_outlet, ffi.Pointer<ffi.Char>, int,
          ffi.Pointer<ffi.Double>, int)>();

  int lsl_push_chunk_strtnp(
    lsl_outlet out,
    ffi.Pointer<ffi.Pointer<ffi.Char>> data,
    int data_elements,
    ffi.Pointer<ffi.Double> timestamps,
    int pushthrough,
  ) {
    return _lsl_push_chunk_strtnp(
      out,
      data,
      data_elements,
      timestamps,
      pushthrough,
    );
  }

  late final _lsl_push_chunk_strtnpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              lsl_outlet,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.Double>,
              ffi.Int32)>>('lsl_push_chunk_strtnp');
  late final _lsl_push_chunk_strtnp = _lsl_push_chunk_strtnpPtr.asFunction<
      int Function(lsl_outlet, ffi.Pointer<ffi.Pointer<ffi.Char>>, int,
          ffi.Pointer<ffi.Double>, int)>();

  /// @copybrief lsl_push_chunk_ftp
  /// @sa lsl_push_chunk_ftp
  /// @param out The lsl_outlet object through which to push the data.
  /// @param data An array of channel values holding the data to push.
  /// @param lengths Pointer the number of elements to push for each value (string lengths) so that
  /// `size(data[i])==lengths[i]`.
  /// @param data_elements The number of data values in the data buffer.
  /// Must be a multiple of the channel count.
  int lsl_push_chunk_buf(
    lsl_outlet out,
    ffi.Pointer<ffi.Pointer<ffi.Char>> data,
    ffi.Pointer<ffi.Uint32> lengths,
    int data_elements,
  ) {
    return _lsl_push_chunk_buf(
      out,
      data,
      lengths,
      data_elements,
    );
  }

  late final _lsl_push_chunk_bufPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              lsl_outlet,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Uint32>,
              ffi.UnsignedLong)>>('lsl_push_chunk_buf');
  late final _lsl_push_chunk_buf = _lsl_push_chunk_bufPtr.asFunction<
      int Function(lsl_outlet, ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Uint32>, int)>();

  /// @copydoc lsl_push_chunk_buf @sa lsl_push_chunk_ftp @sa lsl_push_chunk_buf
  /// @param timestamp Optionally the capture time of the most recent sample, in agreement with
  /// lsl_local_clock(); if omitted, the current time is used.
  /// The time stamps of other samples are automatically derived based on the sampling rate of the
  /// stream.
  int lsl_push_chunk_buft(
    lsl_outlet out,
    ffi.Pointer<ffi.Pointer<ffi.Char>> data,
    ffi.Pointer<ffi.Uint32> lengths,
    int data_elements,
    double timestamp,
  ) {
    return _lsl_push_chunk_buft(
      out,
      data,
      lengths,
      data_elements,
      timestamp,
    );
  }

  late final _lsl_push_chunk_buftPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              lsl_outlet,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Uint32>,
              ffi.UnsignedLong,
              ffi.Double)>>('lsl_push_chunk_buft');
  late final _lsl_push_chunk_buft = _lsl_push_chunk_buftPtr.asFunction<
      int Function(lsl_outlet, ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Uint32>, int, double)>();

  /// @copydoc lsl_push_chunk_buft @sa lsl_push_chunk_ftp @sa lsl_push_chunk_buf
  /// @param pushthrough Whether to push the chunk through to the receivers instead of buffering it
  /// with subsequent samples. Note that the chunk_size, if specified at outlet construction, takes
  /// precedence over the pushthrough flag.
  int lsl_push_chunk_buftp(
    lsl_outlet out,
    ffi.Pointer<ffi.Pointer<ffi.Char>> data,
    ffi.Pointer<ffi.Uint32> lengths,
    int data_elements,
    double timestamp,
    int pushthrough,
  ) {
    return _lsl_push_chunk_buftp(
      out,
      data,
      lengths,
      data_elements,
      timestamp,
      pushthrough,
    );
  }

  late final _lsl_push_chunk_buftpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              lsl_outlet,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Uint32>,
              ffi.UnsignedLong,
              ffi.Double,
              ffi.Int32)>>('lsl_push_chunk_buftp');
  late final _lsl_push_chunk_buftp = _lsl_push_chunk_buftpPtr.asFunction<
      int Function(lsl_outlet, ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Uint32>, int, double, int)>();

  /// @copydoc lsl_push_chunk_buf @sa lsl_push_chunk_ftp @sa lsl_push_chunk_buf
  /// @param timestamps Buffer holding one time stamp for each sample in the data buffer.
  int lsl_push_chunk_buftn(
    lsl_outlet out,
    ffi.Pointer<ffi.Pointer<ffi.Char>> data,
    ffi.Pointer<ffi.Uint32> lengths,
    int data_elements,
    ffi.Pointer<ffi.Double> timestamps,
  ) {
    return _lsl_push_chunk_buftn(
      out,
      data,
      lengths,
      data_elements,
      timestamps,
    );
  }

  late final _lsl_push_chunk_buftnPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              lsl_outlet,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Uint32>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.Double>)>>('lsl_push_chunk_buftn');
  late final _lsl_push_chunk_buftn = _lsl_push_chunk_buftnPtr.asFunction<
      int Function(lsl_outlet, ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Uint32>, int, ffi.Pointer<ffi.Double>)>();

  /// @copydoc lsl_push_chunk_buftn @sa lsl_push_chunk_ftp @sa lsl_push_chunk_buf
  /// @param pushthrough Whether to push the chunk through to the receivers instead of buffering it
  /// with subsequent samples. Note that the chunk_size, if specified at outlet construction, takes
  /// precedence over the pushthrough flag.
  int lsl_push_chunk_buftnp(
    lsl_outlet out,
    ffi.Pointer<ffi.Pointer<ffi.Char>> data,
    ffi.Pointer<ffi.Uint32> lengths,
    int data_elements,
    ffi.Pointer<ffi.Double> timestamps,
    int pushthrough,
  ) {
    return _lsl_push_chunk_buftnp(
      out,
      data,
      lengths,
      data_elements,
      timestamps,
      pushthrough,
    );
  }

  late final _lsl_push_chunk_buftnpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              lsl_outlet,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Uint32>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.Double>,
              ffi.Int32)>>('lsl_push_chunk_buftnp');
  late final _lsl_push_chunk_buftnp = _lsl_push_chunk_buftnpPtr.asFunction<
      int Function(lsl_outlet, ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Uint32>, int, ffi.Pointer<ffi.Double>, int)>();

  /// Check whether consumers are currently registered.
  /// While it does not hurt, there is technically no reason to push samples if there is no consumer.
  int lsl_have_consumers(
    lsl_outlet out,
  ) {
    return _lsl_have_consumers(
      out,
    );
  }

  late final _lsl_have_consumersPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(lsl_outlet)>>(
          'lsl_have_consumers');
  late final _lsl_have_consumers =
      _lsl_have_consumersPtr.asFunction<int Function(lsl_outlet)>();

  /// Wait until some consumer shows up (without wasting resources).
  /// @return True if the wait was successful, false if the timeout expired.
  int lsl_wait_for_consumers(
    lsl_outlet out,
    double timeout,
  ) {
    return _lsl_wait_for_consumers(
      out,
      timeout,
    );
  }

  late final _lsl_wait_for_consumersPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(lsl_outlet, ffi.Double)>>(
          'lsl_wait_for_consumers');
  late final _lsl_wait_for_consumers =
      _lsl_wait_for_consumersPtr.asFunction<int Function(lsl_outlet, double)>();

  /// Retrieve a handle to the stream info provided by this outlet.
  /// This is what was used to create the stream (and also has the Additional Network Information
  /// fields assigned).
  /// @return A copy of the streaminfo of the outlet or NULL in the event that an error occurred.
  /// @note It is the user's responsibility to destroy it when it is no longer needed.
  /// @sa lsl_destroy_string()
  lsl_streaminfo lsl_get_info(
    lsl_outlet out,
  ) {
    return _lsl_get_info(
      out,
    );
  }

  late final _lsl_get_infoPtr =
      _lookup<ffi.NativeFunction<lsl_streaminfo Function(lsl_outlet)>>(
          'lsl_get_info');
  late final _lsl_get_info =
      _lsl_get_infoPtr.asFunction<lsl_streaminfo Function(lsl_outlet)>();

  /// Return an explanation for the last error
  ffi.Pointer<ffi.Char> lsl_last_error() {
    return _lsl_last_error();
  }

  late final _lsl_last_errorPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'lsl_last_error');
  late final _lsl_last_error =
      _lsl_last_errorPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Protocol version.
  ///
  /// The major version is `protocol_version() / 100;`
  /// The minor version is `protocol_version() % 100;`
  ///
  /// Clients with different minor versions are protocol-compatible while clients
  /// with different major versions will refuse to work together.
  int lsl_protocol_version() {
    return _lsl_protocol_version();
  }

  late final _lsl_protocol_versionPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('lsl_protocol_version');
  late final _lsl_protocol_version =
      _lsl_protocol_versionPtr.asFunction<int Function()>();

  /// Version of the liblsl library.
  ///
  /// The major version is `library_version() / 100;`
  /// The minor version is `library_version() % 100;`
  int lsl_library_version() {
    return _lsl_library_version();
  }

  late final _lsl_library_versionPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('lsl_library_version');
  late final _lsl_library_version =
      _lsl_library_versionPtr.asFunction<int Function()>();

  /// Get a string containing library information.
  ///
  /// The format of the string shouldn't be used for anything important except giving a debugging
  /// person a good idea which exact library version is used.
  ffi.Pointer<ffi.Char> lsl_library_info() {
    return _lsl_library_info();
  }

  late final _lsl_library_infoPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'lsl_library_info');
  late final _lsl_library_info =
      _lsl_library_infoPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Obtain a local system time stamp in seconds.
  ///
  /// The resolution is better than a millisecond.
  /// This reading can be used to assign time stamps to samples as they are being acquired.
  /// If the "age" of a sample is known at a particular time (e.g., from USB transmission
  /// delays), it can be used as an offset to lsl_local_clock() to obtain a better estimate of
  /// when a sample was actually captured. See lsl_push_sample() for a use case.
  double lsl_local_clock() {
    return _lsl_local_clock();
  }

  late final _lsl_local_clockPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function()>>('lsl_local_clock');
  late final _lsl_local_clock =
      _lsl_local_clockPtr.asFunction<double Function()>();

  /// Deallocate a string that has been transferred to the application.
  ///
  /// Rarely used: the only use case is to deallocate the contents of
  /// string-valued samples received from LSL in an application where
  /// no free() method is available (e.g., in some scripting languages).
  void lsl_destroy_string(
    ffi.Pointer<ffi.Char> s,
  ) {
    return _lsl_destroy_string(
      s,
    );
  }

  late final _lsl_destroy_stringPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'lsl_destroy_string');
  late final _lsl_destroy_string =
      _lsl_destroy_stringPtr.asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  /// Construct a new stream inlet from a resolved stream info.
  /// @param info A resolved stream info object (as coming from one of the resolver functions).
  /// @note The inlet makes a copy of the info object at its construction.
  /// @note The stream_inlet may also be constructed with a fully-specified stream_info, if the desired
  /// channel format and count is already known up-front, but this is  strongly discouraged and should
  /// only ever be done if there is no time to resolve the  stream up-front (e.g., due to limitations
  /// in the client program).
  /// @param max_buflen Optionally the maximum amount of data to buffer (in seconds if there is a
  /// nominal sampling rate, otherwise x100 in samples).
  ///
  /// Recording applications want to use a fairly large buffer size here, while real-time applications
  /// would only buffer as much as they need to perform their next calculation.
  ///
  /// A good default is 360, which corresponds to 6 minutes of data.
  /// @param max_chunklen Optionally the maximum size, in samples, at which chunks are transmitted.
  /// If specified as 0, the chunk sizes preferred by the sender are used.
  /// Recording applications can use a generous size here (leaving it to the network how  to pack
  /// things), while real-time applications may want a finer (perhaps 1-sample) granularity.
  /// @param recover Try to silently recover lost streams that are recoverable (=those that that have a
  /// source_id set).
  ///
  /// It is generally a good idea to enable this, unless the application wants to act in a special way
  /// when a data provider has temporarily crashed.
  ///
  /// If recover is 0 or the stream is not recoverable, most outlet functions will return an
  /// #lsl_lost_error if the stream's source is lost.
  /// @return A newly created lsl_inlet handle or NULL in the event that an error occurred.
  lsl_inlet lsl_create_inlet(
    lsl_streaminfo info,
    int max_buflen,
    int max_chunklen,
    int recover,
  ) {
    return _lsl_create_inlet(
      info,
      max_buflen,
      max_chunklen,
      recover,
    );
  }

  late final _lsl_create_inletPtr = _lookup<
      ffi.NativeFunction<
          lsl_inlet Function(lsl_streaminfo, ffi.Int32, ffi.Int32,
              ffi.Int32)>>('lsl_create_inlet');
  late final _lsl_create_inlet = _lsl_create_inletPtr
      .asFunction<lsl_inlet Function(lsl_streaminfo, int, int, int)>();

  /// @copydoc lsl_create_inlet()
  /// @param flags An integer that is the result of bitwise OR'ing one or more options from
  /// #lsl_transport_options_t together (e.g., #transp_bufsize_samples)
  lsl_inlet lsl_create_inlet_ex(
    lsl_streaminfo info,
    int max_buflen,
    int max_chunklen,
    int recover,
    lsl_transport_options_t flags,
  ) {
    return _lsl_create_inlet_ex(
      info,
      max_buflen,
      max_chunklen,
      recover,
      flags.value,
    );
  }

  late final _lsl_create_inlet_exPtr = _lookup<
      ffi.NativeFunction<
          lsl_inlet Function(lsl_streaminfo, ffi.Int32, ffi.Int32, ffi.Int32,
              ffi.UnsignedInt)>>('lsl_create_inlet_ex');
  late final _lsl_create_inlet_ex = _lsl_create_inlet_exPtr
      .asFunction<lsl_inlet Function(lsl_streaminfo, int, int, int, int)>();

  /// Destructor.
  /// The inlet will automatically disconnect if destroyed.
  void lsl_destroy_inlet(
    lsl_inlet in1,
  ) {
    return _lsl_destroy_inlet(
      in1,
    );
  }

  late final _lsl_destroy_inletPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(lsl_inlet)>>(
          'lsl_destroy_inlet');
  late final _lsl_destroy_inlet =
      _lsl_destroy_inletPtr.asFunction<void Function(lsl_inlet)>();

  /// Retrieve the complete information of the given stream, including the extended description.
  /// Can be invoked at any time of the stream's lifetime.
  /// @param in The lsl_inlet object to act on.
  /// @param timeout Timeout of the operation. Use LSL_FOREVER to effectively disable it.
  /// @param[out] ec Error code: if nonzero, can be either lsl_timeout_error (if the timeout has
  /// expired) or #lsl_lost_error (if the stream source has been lost).
  /// @return A copy of the full streaminfo of the inlet or NULL in the event that an error happened.
  /// @note It is the user's responsibility to destroy it when it is no longer needed.
  lsl_streaminfo lsl_get_fullinfo(
    lsl_inlet in1,
    double timeout,
    ffi.Pointer<ffi.Int32> ec,
  ) {
    return _lsl_get_fullinfo(
      in1,
      timeout,
      ec,
    );
  }

  late final _lsl_get_fullinfoPtr = _lookup<
      ffi.NativeFunction<
          lsl_streaminfo Function(lsl_inlet, ffi.Double,
              ffi.Pointer<ffi.Int32>)>>('lsl_get_fullinfo');
  late final _lsl_get_fullinfo = _lsl_get_fullinfoPtr.asFunction<
      lsl_streaminfo Function(lsl_inlet, double, ffi.Pointer<ffi.Int32>)>();

  /// Subscribe to the data stream.
  ///
  /// All samples pushed in at the other end from this moment onwards will be queued and
  /// eventually be delivered in response to pull_sample() calls.
  /// Pulling a sample without some preceding lsl_open_stream() is permitted (the stream will then be
  /// opened implicitly).
  /// @param in The lsl_inlet object to act on.
  /// @param timeout Optional timeout of the operation. Use LSL_FOREVER to effectively disable it.
  /// @param[out] ec Error code: if nonzero, can be either #lsl_timeout_error (if the timeout has
  /// expired) or lsl_lost_error (if the stream source has been lost).
  void lsl_open_stream(
    lsl_inlet in1,
    double timeout,
    ffi.Pointer<ffi.Int32> ec,
  ) {
    return _lsl_open_stream(
      in1,
      timeout,
      ec,
    );
  }

  late final _lsl_open_streamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(lsl_inlet, ffi.Double,
              ffi.Pointer<ffi.Int32>)>>('lsl_open_stream');
  late final _lsl_open_stream = _lsl_open_streamPtr
      .asFunction<void Function(lsl_inlet, double, ffi.Pointer<ffi.Int32>)>();

  /// Drop the current data stream.
  ///
  /// All samples that are still buffered or in flight will be dropped and transmission
  /// and buffering of data for this inlet will be stopped. If an application stops being
  /// interested in data from a source (temporarily or not) but keeps the outlet alive,
  /// it should call lsl_close_stream() to not waste unnecessary system and network
  /// resources.
  void lsl_close_stream(
    lsl_inlet in1,
  ) {
    return _lsl_close_stream(
      in1,
    );
  }

  late final _lsl_close_streamPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(lsl_inlet)>>(
          'lsl_close_stream');
  late final _lsl_close_stream =
      _lsl_close_streamPtr.asFunction<void Function(lsl_inlet)>();

  /// @brief Retrieve an estimated time correction offset for the given stream.
  ///
  /// The first call to this function takes several milliseconds until a reliable first estimate is
  /// obtained. Subsequent calls are instantaneous (and rely on periodic background updates).
  ///
  /// On a well-behaved network, the precision of these estimates should be below 1 ms (empirically it
  /// is within +/-0.2 ms).
  ///
  /// To get a measure of whether the network is well-behaved, use #lsl_time_correction_ex and check
  /// uncertainty (which maps to round-trip-time). 0.2 ms is typical of wired networks.
  ///
  /// 2 ms is typical of wireless networks. The number can be much higher on poor networks.
  ///
  /// @param in The lsl_inlet object to act on.
  /// @param timeout Timeout to acquire the first time-correction estimate.
  /// Use LSL_FOREVER to defuse the timeout.
  /// @param[out] ec Error code: if nonzero, can be either #lsl_timeout_error (if the timeout has
  /// expired) or lsl_lost_error (if the stream source has been lost).
  /// @return The time correction estimate.
  /// This is the number that needs to be added to a time stamp that was remotely generated via
  /// lsl_local_clock() to map it into the local clock domain of this machine.
  double lsl_time_correction(
    lsl_inlet in1,
    double timeout,
    ffi.Pointer<ffi.Int32> ec,
  ) {
    return _lsl_time_correction(
      in1,
      timeout,
      ec,
    );
  }

  late final _lsl_time_correctionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(lsl_inlet, ffi.Double,
              ffi.Pointer<ffi.Int32>)>>('lsl_time_correction');
  late final _lsl_time_correction = _lsl_time_correctionPtr
      .asFunction<double Function(lsl_inlet, double, ffi.Pointer<ffi.Int32>)>();

  /// @copydoc lsl_time_correction()
  /// @param remote_time The current time of the remote computer that was used to generate this
  /// time_correction.
  /// If desired, the client can fit time_correction vs remote_time to improve the real-time
  /// time_correction further.
  /// @param uncertainty The maximum uncertainty of the given time correction.
  double lsl_time_correction_ex(
    lsl_inlet in1,
    ffi.Pointer<ffi.Double> remote_time,
    ffi.Pointer<ffi.Double> uncertainty,
    double timeout,
    ffi.Pointer<ffi.Int32> ec,
  ) {
    return _lsl_time_correction_ex(
      in1,
      remote_time,
      uncertainty,
      timeout,
      ec,
    );
  }

  late final _lsl_time_correction_exPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(
              lsl_inlet,
              ffi.Pointer<ffi.Double>,
              ffi.Pointer<ffi.Double>,
              ffi.Double,
              ffi.Pointer<ffi.Int32>)>>('lsl_time_correction_ex');
  late final _lsl_time_correction_ex = _lsl_time_correction_exPtr.asFunction<
      double Function(lsl_inlet, ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>, double, ffi.Pointer<ffi.Int32>)>();

  /// Set post-processing flags to use.
  ///
  /// By default, the inlet performs NO post-processing and returns the ground-truth time stamps, which
  /// can then be manually synchronized using time_correction(), and then smoothed/dejittered if
  /// desired.
  ///
  /// This function allows automating these two and possibly more operations.
  /// @warning When you enable this, you will no longer receive or be able to recover the original time
  /// stamps.
  /// @param in The lsl_inlet object to act on.
  /// @param flags An integer that is the result of bitwise OR'ing one or more options from
  /// #lsl_processing_options_t together (e.g., #proc_clocksync|#proc_dejitter);
  /// a good setting is to use #proc_ALL.
  /// @return The error code: if nonzero, can be #lsl_argument_error if an unknown flag was passed in.
  int lsl_set_postprocessing(
    lsl_inlet in1,
    int flags,
  ) {
    return _lsl_set_postprocessing(
      in1,
      flags,
    );
  }

  late final _lsl_set_postprocessingPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(lsl_inlet, ffi.Uint32)>>(
          'lsl_set_postprocessing');
  late final _lsl_set_postprocessing =
      _lsl_set_postprocessingPtr.asFunction<int Function(lsl_inlet, int)>();

  /// Pull a sample from the inlet and read it into a pointer to values.
  /// Handles type checking & conversion.
  /// @param in The #lsl_inlet object to act on.
  /// @param[out] buffer A pointer to hold the resulting values.
  /// @param buffer_elements The number of samples allocated in the buffer.
  /// @attention It is the responsibility of the user to allocate enough memory.
  /// @param timeout The timeout for this operation, if any.
  /// Use #LSL_FOREVER to effectively disable it. It is also permitted to use 0.0 here;
  /// in this case a sample is only returned if one is currently buffered.
  /// @param[out] ec Error code: can be either no error or #lsl_lost_error
  /// (if the stream source has been lost).<br>
  /// @note If the timeout expires before a new sample was received the function returns 0.0;
  /// ec is *not* set to #lsl_timeout_error (because this case is not considered an error condition).
  /// @return The capture time of the sample on the remote machine, or 0.0 if no new sample was
  /// available. To remap this time stamp to the local clock, add the value returned by
  /// lsl_time_correction() to it.
  /// @{
  double lsl_pull_sample_f(
    lsl_inlet in1,
    ffi.Pointer<ffi.Float> buffer,
    int buffer_elements,
    double timeout,
    ffi.Pointer<ffi.Int32> ec,
  ) {
    return _lsl_pull_sample_f(
      in1,
      buffer,
      buffer_elements,
      timeout,
      ec,
    );
  }

  late final _lsl_pull_sample_fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(lsl_inlet, ffi.Pointer<ffi.Float>, ffi.Int32,
              ffi.Double, ffi.Pointer<ffi.Int32>)>>('lsl_pull_sample_f');
  late final _lsl_pull_sample_f = _lsl_pull_sample_fPtr.asFunction<
      double Function(lsl_inlet, ffi.Pointer<ffi.Float>, int, double,
          ffi.Pointer<ffi.Int32>)>();

  double lsl_pull_sample_d(
    lsl_inlet in1,
    ffi.Pointer<ffi.Double> buffer,
    int buffer_elements,
    double timeout,
    ffi.Pointer<ffi.Int32> ec,
  ) {
    return _lsl_pull_sample_d(
      in1,
      buffer,
      buffer_elements,
      timeout,
      ec,
    );
  }

  late final _lsl_pull_sample_dPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(lsl_inlet, ffi.Pointer<ffi.Double>, ffi.Int32,
              ffi.Double, ffi.Pointer<ffi.Int32>)>>('lsl_pull_sample_d');
  late final _lsl_pull_sample_d = _lsl_pull_sample_dPtr.asFunction<
      double Function(lsl_inlet, ffi.Pointer<ffi.Double>, int, double,
          ffi.Pointer<ffi.Int32>)>();

  double lsl_pull_sample_l(
    lsl_inlet in1,
    ffi.Pointer<ffi.Int64> buffer,
    int buffer_elements,
    double timeout,
    ffi.Pointer<ffi.Int32> ec,
  ) {
    return _lsl_pull_sample_l(
      in1,
      buffer,
      buffer_elements,
      timeout,
      ec,
    );
  }

  late final _lsl_pull_sample_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(lsl_inlet, ffi.Pointer<ffi.Int64>, ffi.Int32,
              ffi.Double, ffi.Pointer<ffi.Int32>)>>('lsl_pull_sample_l');
  late final _lsl_pull_sample_l = _lsl_pull_sample_lPtr.asFunction<
      double Function(lsl_inlet, ffi.Pointer<ffi.Int64>, int, double,
          ffi.Pointer<ffi.Int32>)>();

  double lsl_pull_sample_i(
    lsl_inlet in1,
    ffi.Pointer<ffi.Int32> buffer,
    int buffer_elements,
    double timeout,
    ffi.Pointer<ffi.Int32> ec,
  ) {
    return _lsl_pull_sample_i(
      in1,
      buffer,
      buffer_elements,
      timeout,
      ec,
    );
  }

  late final _lsl_pull_sample_iPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(lsl_inlet, ffi.Pointer<ffi.Int32>, ffi.Int32,
              ffi.Double, ffi.Pointer<ffi.Int32>)>>('lsl_pull_sample_i');
  late final _lsl_pull_sample_i = _lsl_pull_sample_iPtr.asFunction<
      double Function(lsl_inlet, ffi.Pointer<ffi.Int32>, int, double,
          ffi.Pointer<ffi.Int32>)>();

  double lsl_pull_sample_s(
    lsl_inlet in1,
    ffi.Pointer<ffi.Int16> buffer,
    int buffer_elements,
    double timeout,
    ffi.Pointer<ffi.Int32> ec,
  ) {
    return _lsl_pull_sample_s(
      in1,
      buffer,
      buffer_elements,
      timeout,
      ec,
    );
  }

  late final _lsl_pull_sample_sPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(lsl_inlet, ffi.Pointer<ffi.Int16>, ffi.Int32,
              ffi.Double, ffi.Pointer<ffi.Int32>)>>('lsl_pull_sample_s');
  late final _lsl_pull_sample_s = _lsl_pull_sample_sPtr.asFunction<
      double Function(lsl_inlet, ffi.Pointer<ffi.Int16>, int, double,
          ffi.Pointer<ffi.Int32>)>();

  double lsl_pull_sample_c(
    lsl_inlet in1,
    ffi.Pointer<ffi.Char> buffer,
    int buffer_elements,
    double timeout,
    ffi.Pointer<ffi.Int32> ec,
  ) {
    return _lsl_pull_sample_c(
      in1,
      buffer,
      buffer_elements,
      timeout,
      ec,
    );
  }

  late final _lsl_pull_sample_cPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(lsl_inlet, ffi.Pointer<ffi.Char>, ffi.Int32,
              ffi.Double, ffi.Pointer<ffi.Int32>)>>('lsl_pull_sample_c');
  late final _lsl_pull_sample_c = _lsl_pull_sample_cPtr.asFunction<
      double Function(lsl_inlet, ffi.Pointer<ffi.Char>, int, double,
          ffi.Pointer<ffi.Int32>)>();

  double lsl_pull_sample_str(
    lsl_inlet in1,
    ffi.Pointer<ffi.Pointer<ffi.Char>> buffer,
    int buffer_elements,
    double timeout,
    ffi.Pointer<ffi.Int32> ec,
  ) {
    return _lsl_pull_sample_str(
      in1,
      buffer,
      buffer_elements,
      timeout,
      ec,
    );
  }

  late final _lsl_pull_sample_strPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(
              lsl_inlet,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Int32,
              ffi.Double,
              ffi.Pointer<ffi.Int32>)>>('lsl_pull_sample_str');
  late final _lsl_pull_sample_str = _lsl_pull_sample_strPtr.asFunction<
      double Function(lsl_inlet, ffi.Pointer<ffi.Pointer<ffi.Char>>, int,
          double, ffi.Pointer<ffi.Int32>)>();

  /// @copydoc lsl_pull_sample_f
  /// These strings may contains 0's, therefore the lengths are read into the buffer_lengths array.
  /// @param buffer_lengths
  /// A pointer to an array that holds the resulting lengths for each returned binary string.
  double lsl_pull_sample_buf(
    lsl_inlet in1,
    ffi.Pointer<ffi.Pointer<ffi.Char>> buffer,
    ffi.Pointer<ffi.Uint32> buffer_lengths,
    int buffer_elements,
    double timeout,
    ffi.Pointer<ffi.Int32> ec,
  ) {
    return _lsl_pull_sample_buf(
      in1,
      buffer,
      buffer_lengths,
      buffer_elements,
      timeout,
      ec,
    );
  }

  late final _lsl_pull_sample_bufPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(
              lsl_inlet,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Uint32>,
              ffi.Int32,
              ffi.Double,
              ffi.Pointer<ffi.Int32>)>>('lsl_pull_sample_buf');
  late final _lsl_pull_sample_buf = _lsl_pull_sample_bufPtr.asFunction<
      double Function(lsl_inlet, ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Uint32>, int, double, ffi.Pointer<ffi.Int32>)>();

  /// Pull a sample from the inlet and read it into a custom struct or buffer.
  ///
  /// Overall size checking but no type checking or conversion are done.
  /// Do not use for variable-size/string-formatted streams.
  /// @param in The #lsl_inlet object to act on.
  /// @param[out] buffer A pointer to hold the resulting values.
  /// @param buffer_bytes Length of the array held by buffer in bytes, not items
  /// @param timeout The timeout for this operation, if any.
  /// Use #LSL_FOREVER to effectively disable it. It is also permitted to use 0.0 here;
  /// in this case a sample is only returned if one is currently buffered.
  /// @param[out] ec Error code: can be either no error or #lsl_lost_error
  /// (if the stream source has been lost).<br>
  /// @note If the timeout expires before a new sample was received the function returns 0.0;
  /// ec is *not* set to #lsl_timeout_error (because this case is not considered an error condition).
  /// @return The capture time of the sample on the remote machine, or 0.0 if no new sample was
  /// available. To remap this time stamp to the local clock, add the value returned by
  /// lsl_time_correction() to it.
  double lsl_pull_sample_v(
    lsl_inlet in1,
    ffi.Pointer<ffi.Void> buffer,
    int buffer_bytes,
    double timeout,
    ffi.Pointer<ffi.Int32> ec,
  ) {
    return _lsl_pull_sample_v(
      in1,
      buffer,
      buffer_bytes,
      timeout,
      ec,
    );
  }

  late final _lsl_pull_sample_vPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(lsl_inlet, ffi.Pointer<ffi.Void>, ffi.Int32,
              ffi.Double, ffi.Pointer<ffi.Int32>)>>('lsl_pull_sample_v');
  late final _lsl_pull_sample_v = _lsl_pull_sample_vPtr.asFunction<
      double Function(lsl_inlet, ffi.Pointer<ffi.Void>, int, double,
          ffi.Pointer<ffi.Int32>)>();

  /// Pull a chunk of data from the inlet and read it into a buffer.
  ///
  /// Handles type checking & conversion.
  ///
  /// @attention Note that the provided data buffer size is measured in channel values (e.g. floats)
  /// rather than in samples.
  /// @param in The lsl_inlet object to act on.
  /// @param[out] data_buffer A pointer to a buffer of data values where the results shall be stored.
  /// @param[out] timestamp_buffer A pointer to a double buffer where time stamps shall be stored.
  ///
  /// If this is NULL, no time stamps will be returned.
  /// @param data_buffer_elements The size of the data buffer, in channel data elements (of type T).
  /// Must be a multiple of the stream's channel count.
  /// @param timestamp_buffer_elements The size of the timestamp buffer.
  ///
  /// If a timestamp buffer is provided then this must correspond to the same number of samples as
  /// data_buffer_elements.
  /// @param timeout The timeout for this operation, if any.
  ///
  /// When the timeout expires, the function may return before the entire buffer is filled.
  /// The default value of 0.0 will retrieve only data available for immediate pickup.
  /// @param[out] ec Error code: can be either no error or #lsl_lost_error (if the stream source has
  /// been lost).
  /// @note if the timeout expires before a new sample was received the function returns 0.0;
  /// ec is *not* set to #lsl_timeout_error (because this case is not considered an error condition).
  /// @return data_elements_written Number of channel data elements written to the data buffer.
  /// @{
  int lsl_pull_chunk_f(
    lsl_inlet in1,
    ffi.Pointer<ffi.Float> data_buffer,
    ffi.Pointer<ffi.Double> timestamp_buffer,
    int data_buffer_elements,
    int timestamp_buffer_elements,
    double timeout,
    ffi.Pointer<ffi.Int32> ec,
  ) {
    return _lsl_pull_chunk_f(
      in1,
      data_buffer,
      timestamp_buffer,
      data_buffer_elements,
      timestamp_buffer_elements,
      timeout,
      ec,
    );
  }

  late final _lsl_pull_chunk_fPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              lsl_inlet,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Double>,
              ffi.UnsignedLong,
              ffi.UnsignedLong,
              ffi.Double,
              ffi.Pointer<ffi.Int32>)>>('lsl_pull_chunk_f');
  late final _lsl_pull_chunk_f = _lsl_pull_chunk_fPtr.asFunction<
      int Function(lsl_inlet, ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.Double>,
          int, int, double, ffi.Pointer<ffi.Int32>)>();

  int lsl_pull_chunk_d(
    lsl_inlet in1,
    ffi.Pointer<ffi.Double> data_buffer,
    ffi.Pointer<ffi.Double> timestamp_buffer,
    int data_buffer_elements,
    int timestamp_buffer_elements,
    double timeout,
    ffi.Pointer<ffi.Int32> ec,
  ) {
    return _lsl_pull_chunk_d(
      in1,
      data_buffer,
      timestamp_buffer,
      data_buffer_elements,
      timestamp_buffer_elements,
      timeout,
      ec,
    );
  }

  late final _lsl_pull_chunk_dPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              lsl_inlet,
              ffi.Pointer<ffi.Double>,
              ffi.Pointer<ffi.Double>,
              ffi.UnsignedLong,
              ffi.UnsignedLong,
              ffi.Double,
              ffi.Pointer<ffi.Int32>)>>('lsl_pull_chunk_d');
  late final _lsl_pull_chunk_d = _lsl_pull_chunk_dPtr.asFunction<
      int Function(lsl_inlet, ffi.Pointer<ffi.Double>, ffi.Pointer<ffi.Double>,
          int, int, double, ffi.Pointer<ffi.Int32>)>();

  int lsl_pull_chunk_l(
    lsl_inlet in1,
    ffi.Pointer<ffi.Int64> data_buffer,
    ffi.Pointer<ffi.Double> timestamp_buffer,
    int data_buffer_elements,
    int timestamp_buffer_elements,
    double timeout,
    ffi.Pointer<ffi.Int32> ec,
  ) {
    return _lsl_pull_chunk_l(
      in1,
      data_buffer,
      timestamp_buffer,
      data_buffer_elements,
      timestamp_buffer_elements,
      timeout,
      ec,
    );
  }

  late final _lsl_pull_chunk_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              lsl_inlet,
              ffi.Pointer<ffi.Int64>,
              ffi.Pointer<ffi.Double>,
              ffi.UnsignedLong,
              ffi.UnsignedLong,
              ffi.Double,
              ffi.Pointer<ffi.Int32>)>>('lsl_pull_chunk_l');
  late final _lsl_pull_chunk_l = _lsl_pull_chunk_lPtr.asFunction<
      int Function(lsl_inlet, ffi.Pointer<ffi.Int64>, ffi.Pointer<ffi.Double>,
          int, int, double, ffi.Pointer<ffi.Int32>)>();

  int lsl_pull_chunk_i(
    lsl_inlet in1,
    ffi.Pointer<ffi.Int32> data_buffer,
    ffi.Pointer<ffi.Double> timestamp_buffer,
    int data_buffer_elements,
    int timestamp_buffer_elements,
    double timeout,
    ffi.Pointer<ffi.Int32> ec,
  ) {
    return _lsl_pull_chunk_i(
      in1,
      data_buffer,
      timestamp_buffer,
      data_buffer_elements,
      timestamp_buffer_elements,
      timeout,
      ec,
    );
  }

  late final _lsl_pull_chunk_iPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              lsl_inlet,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Double>,
              ffi.UnsignedLong,
              ffi.UnsignedLong,
              ffi.Double,
              ffi.Pointer<ffi.Int32>)>>('lsl_pull_chunk_i');
  late final _lsl_pull_chunk_i = _lsl_pull_chunk_iPtr.asFunction<
      int Function(lsl_inlet, ffi.Pointer<ffi.Int32>, ffi.Pointer<ffi.Double>,
          int, int, double, ffi.Pointer<ffi.Int32>)>();

  int lsl_pull_chunk_s(
    lsl_inlet in1,
    ffi.Pointer<ffi.Int16> data_buffer,
    ffi.Pointer<ffi.Double> timestamp_buffer,
    int data_buffer_elements,
    int timestamp_buffer_elements,
    double timeout,
    ffi.Pointer<ffi.Int32> ec,
  ) {
    return _lsl_pull_chunk_s(
      in1,
      data_buffer,
      timestamp_buffer,
      data_buffer_elements,
      timestamp_buffer_elements,
      timeout,
      ec,
    );
  }

  late final _lsl_pull_chunk_sPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              lsl_inlet,
              ffi.Pointer<ffi.Int16>,
              ffi.Pointer<ffi.Double>,
              ffi.UnsignedLong,
              ffi.UnsignedLong,
              ffi.Double,
              ffi.Pointer<ffi.Int32>)>>('lsl_pull_chunk_s');
  late final _lsl_pull_chunk_s = _lsl_pull_chunk_sPtr.asFunction<
      int Function(lsl_inlet, ffi.Pointer<ffi.Int16>, ffi.Pointer<ffi.Double>,
          int, int, double, ffi.Pointer<ffi.Int32>)>();

  int lsl_pull_chunk_c(
    lsl_inlet in1,
    ffi.Pointer<ffi.Char> data_buffer,
    ffi.Pointer<ffi.Double> timestamp_buffer,
    int data_buffer_elements,
    int timestamp_buffer_elements,
    double timeout,
    ffi.Pointer<ffi.Int32> ec,
  ) {
    return _lsl_pull_chunk_c(
      in1,
      data_buffer,
      timestamp_buffer,
      data_buffer_elements,
      timestamp_buffer_elements,
      timeout,
      ec,
    );
  }

  late final _lsl_pull_chunk_cPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              lsl_inlet,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Double>,
              ffi.UnsignedLong,
              ffi.UnsignedLong,
              ffi.Double,
              ffi.Pointer<ffi.Int32>)>>('lsl_pull_chunk_c');
  late final _lsl_pull_chunk_c = _lsl_pull_chunk_cPtr.asFunction<
      int Function(lsl_inlet, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Double>,
          int, int, double, ffi.Pointer<ffi.Int32>)>();

  int lsl_pull_chunk_str(
    lsl_inlet in1,
    ffi.Pointer<ffi.Pointer<ffi.Char>> data_buffer,
    ffi.Pointer<ffi.Double> timestamp_buffer,
    int data_buffer_elements,
    int timestamp_buffer_elements,
    double timeout,
    ffi.Pointer<ffi.Int32> ec,
  ) {
    return _lsl_pull_chunk_str(
      in1,
      data_buffer,
      timestamp_buffer,
      data_buffer_elements,
      timestamp_buffer_elements,
      timeout,
      ec,
    );
  }

  late final _lsl_pull_chunk_strPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              lsl_inlet,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Double>,
              ffi.UnsignedLong,
              ffi.UnsignedLong,
              ffi.Double,
              ffi.Pointer<ffi.Int32>)>>('lsl_pull_chunk_str');
  late final _lsl_pull_chunk_str = _lsl_pull_chunk_strPtr.asFunction<
      int Function(lsl_inlet, ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Double>, int, int, double, ffi.Pointer<ffi.Int32>)>();

  /// Pull a chunk of data from the inlet and read it into an array of binary strings.
  ///
  /// These strings may contains 0's, therefore the lengths are read into the lengths_buffer array.
  /// Handles type checking & conversion.
  /// IMPORTANT: Note that the provided data buffer size is measured in channel values (e.g., floats)
  /// rather than in samples.
  /// @param in The lsl_inlet object to act on.
  /// @param[out] data_buffer A pointer to a buffer of data values where the results shall be stored.
  /// @param[out] lengths_buffer A pointer to an array that holds the resulting lengths for each
  /// returned binary string.
  /// @param timestamp_buffer A pointer to a buffer of timestamp values where time stamps shall be
  /// stored. If this is NULL, no time stamps will be returned.
  /// @param data_buffer_elements The size of the data buffer, in channel data elements (of type T).
  /// Must be a multiple of the stream's channel count.
  /// @param timestamp_buffer_elements The size of the timestamp buffer. If a timestamp buffer is
  /// provided then this must correspond to the same number of samples as data_buffer_elements.
  /// @param timeout The timeout for this operation, if any.
  ///
  /// When the timeout expires, the function may return before the entire buffer is filled.
  ///
  /// The default value of 0.0 will retrieve only data available for immediate pickup.
  /// @param[out] ec Error code: can be either no error or #lsl_lost_error (if the stream source has
  /// been lost).
  /// @note If the timeout expires before a new sample was received the function returns 0.0; ec is
  /// *not* set to #lsl_timeout_error (because this case is not considered an error condition).
  /// @return data_elements_written Number of channel data elements written to the data buffer.
  int lsl_pull_chunk_buf(
    lsl_inlet in1,
    ffi.Pointer<ffi.Pointer<ffi.Char>> data_buffer,
    ffi.Pointer<ffi.Uint32> lengths_buffer,
    ffi.Pointer<ffi.Double> timestamp_buffer,
    int data_buffer_elements,
    int timestamp_buffer_elements,
    double timeout,
    ffi.Pointer<ffi.Int32> ec,
  ) {
    return _lsl_pull_chunk_buf(
      in1,
      data_buffer,
      lengths_buffer,
      timestamp_buffer,
      data_buffer_elements,
      timestamp_buffer_elements,
      timeout,
      ec,
    );
  }

  late final _lsl_pull_chunk_bufPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              lsl_inlet,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Uint32>,
              ffi.Pointer<ffi.Double>,
              ffi.UnsignedLong,
              ffi.UnsignedLong,
              ffi.Double,
              ffi.Pointer<ffi.Int32>)>>('lsl_pull_chunk_buf');
  late final _lsl_pull_chunk_buf = _lsl_pull_chunk_bufPtr.asFunction<
      int Function(
          lsl_inlet,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Uint32>,
          ffi.Pointer<ffi.Double>,
          int,
          int,
          double,
          ffi.Pointer<ffi.Int32>)>();

  /// Query whether samples are currently available for immediate pickup.
  ///
  /// Note that it is not a good idea to use samples_available() to determine whether
  /// a pull_*() call would block: to be sure, set the pull timeout to 0.0 or an acceptably
  /// low value. If the underlying implementation supports it, the value will be the number of
  /// samples available (otherwise it will be 1 or 0).
  int lsl_samples_available(
    lsl_inlet in1,
  ) {
    return _lsl_samples_available(
      in1,
    );
  }

  late final _lsl_samples_availablePtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(lsl_inlet)>>(
          'lsl_samples_available');
  late final _lsl_samples_available =
      _lsl_samples_availablePtr.asFunction<int Function(lsl_inlet)>();

  /// Drop all queued not-yet pulled samples, return the nr of dropped samples
  int lsl_inlet_flush(
    lsl_inlet in1,
  ) {
    return _lsl_inlet_flush(
      in1,
    );
  }

  late final _lsl_inlet_flushPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(lsl_inlet)>>(
          'lsl_inlet_flush');
  late final _lsl_inlet_flush =
      _lsl_inlet_flushPtr.asFunction<int Function(lsl_inlet)>();

  /// Query whether the clock was potentially reset since the last call to lsl_was_clock_reset().
  ///
  /// This is rarely-used function is only needed for applications that combine multiple time_correction
  /// values to estimate precise clock drift if they should tolerate cases where the source machine was
  /// hot-swapped or restarted.
  int lsl_was_clock_reset(
    lsl_inlet in1,
  ) {
    return _lsl_was_clock_reset(
      in1,
    );
  }

  late final _lsl_was_clock_resetPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(lsl_inlet)>>(
          'lsl_was_clock_reset');
  late final _lsl_was_clock_reset =
      _lsl_was_clock_resetPtr.asFunction<int Function(lsl_inlet)>();

  /// Override the half-time (forget factor) of the time-stamp smoothing.
  ///
  /// The default is 90 seconds unless a different value is set in the config file.
  ///
  /// Using a longer window will yield lower jitter in the time stamps, but longer windows will have
  /// trouble tracking changes in the clock rate (usually due to  temperature changes); the default is
  /// able to track changes up to 10  degrees C per minute sufficiently well.
  /// @param in The lsl_inlet object to act on.
  /// @param value The new value, in seconds. This is the time after which a past sample
  /// will be weighted by 1/2 in the exponential smoothing window.
  /// @return The error code: if nonzero, can be #lsl_argument_error if an unknown flag was passed in.
  int lsl_smoothing_halftime(
    lsl_inlet in1,
    double value,
  ) {
    return _lsl_smoothing_halftime(
      in1,
      value,
    );
  }

  late final _lsl_smoothing_halftimePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(lsl_inlet, ffi.Float)>>(
          'lsl_smoothing_halftime');
  late final _lsl_smoothing_halftime =
      _lsl_smoothing_halftimePtr.asFunction<int Function(lsl_inlet, double)>();

  /// Construct a new streaminfo object.
  ///
  /// Core stream information is specified here. Any remaining meta-data can be added later.
  /// @param name Name of the stream.<br>
  /// Describes the device (or product series) that this stream makes available
  /// (for use by programs, experimenters or data analysts). Cannot be empty.
  /// @param type Content type of the stream. Please see https://github.com/sccn/xdf/wiki/Meta-Data (or
  /// web search for: XDF meta-data) for pre-defined content-type names, but you can also make up your
  /// own. The content type is the preferred way to find streams (as opposed to searching by name).
  /// @param channel_count Number of channels per sample.
  /// This stays constant for the lifetime of the stream.
  /// @param nominal_srate The sampling rate (in Hz) as advertised by the
  /// datasource, if regular (otherwise set to #LSL_IRREGULAR_RATE).
  /// @param channel_format Format/type of each channel.<br>
  /// If your channels have different formats, consider supplying multiple streams
  /// or use the largest type that can hold them all (such as #cft_double64).
  ///
  /// A good default is #cft_float32.
  /// @param source_id Unique identifier of the source or device, if available (e.g. a serial number).
  /// Allows recipients to recover from failure even after the serving app or device crashes.
  /// May in some cases also be constructed from device settings.
  /// @return A newly created streaminfo handle or NULL in the event that an error occurred.
  lsl_streaminfo lsl_create_streaminfo(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> type,
    int channel_count,
    double nominal_srate,
    lsl_channel_format_t channel_format,
    ffi.Pointer<ffi.Char> source_id,
  ) {
    return _lsl_create_streaminfo(
      name,
      type,
      channel_count,
      nominal_srate,
      channel_format.value,
      source_id,
    );
  }

  late final _lsl_create_streaminfoPtr = _lookup<
      ffi.NativeFunction<
          lsl_streaminfo Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Int32,
              ffi.Double,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Char>)>>('lsl_create_streaminfo');
  late final _lsl_create_streaminfo = _lsl_create_streaminfoPtr.asFunction<
      lsl_streaminfo Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int,
          double, int, ffi.Pointer<ffi.Char>)>();

  /// Destroy a previously created streaminfo object.
  void lsl_destroy_streaminfo(
    lsl_streaminfo info,
  ) {
    return _lsl_destroy_streaminfo(
      info,
    );
  }

  late final _lsl_destroy_streaminfoPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(lsl_streaminfo)>>(
          'lsl_destroy_streaminfo');
  late final _lsl_destroy_streaminfo =
      _lsl_destroy_streaminfoPtr.asFunction<void Function(lsl_streaminfo)>();

  /// Copy an existing streaminfo object (rarely used).
  lsl_streaminfo lsl_copy_streaminfo(
    lsl_streaminfo info,
  ) {
    return _lsl_copy_streaminfo(
      info,
    );
  }

  late final _lsl_copy_streaminfoPtr =
      _lookup<ffi.NativeFunction<lsl_streaminfo Function(lsl_streaminfo)>>(
          'lsl_copy_streaminfo');
  late final _lsl_copy_streaminfo = _lsl_copy_streaminfoPtr
      .asFunction<lsl_streaminfo Function(lsl_streaminfo)>();

  /// Name of the stream.
  ///
  /// This is a human-readable name.
  /// For streams offered by device modules, it refers to the type of device or product series  that is
  /// generating the data of the stream. If the source is an application, the name may be a more
  /// generic or specific identifier. Multiple streams with the same name can coexist, though
  /// potentially at the cost of ambiguity (for the recording app or experimenter).
  /// @return An immutable library-owned pointer to the string value. @sa lsl_destroy_string()
  ffi.Pointer<ffi.Char> lsl_get_name(
    lsl_streaminfo info,
  ) {
    return _lsl_get_name(
      info,
    );
  }

  late final _lsl_get_namePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(lsl_streaminfo)>>(
      'lsl_get_name');
  late final _lsl_get_name = _lsl_get_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(lsl_streaminfo)>();

  /// Content type of the stream.
  ///
  /// The content type is a short string such as "EEG", "Gaze" which describes the content carried by
  /// the channel (if known). If a stream contains mixed content this value need not be assigned but
  /// may instead be stored in the description of channel types. To be useful to applications and
  /// automated processing systems using the recommended content types is preferred. Content types
  /// usually follow those pre-defined in the [wiki](https://github.com/sccn/xdf/wiki/Meta-Data) (or
  /// web search for: XDF meta-data).
  /// @return An immutable library-owned pointer to the string value. @sa lsl_destroy_string()
  ffi.Pointer<ffi.Char> lsl_get_type(
    lsl_streaminfo info,
  ) {
    return _lsl_get_type(
      info,
    );
  }

  late final _lsl_get_typePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(lsl_streaminfo)>>(
      'lsl_get_type');
  late final _lsl_get_type = _lsl_get_typePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(lsl_streaminfo)>();

  /// Number of channels of the stream.
  /// A stream has at least one channels; the channel count stays constant for all samples.
  int lsl_get_channel_count(
    lsl_streaminfo info,
  ) {
    return _lsl_get_channel_count(
      info,
    );
  }

  late final _lsl_get_channel_countPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(lsl_streaminfo)>>(
          'lsl_get_channel_count');
  late final _lsl_get_channel_count =
      _lsl_get_channel_countPtr.asFunction<int Function(lsl_streaminfo)>();

  /// Sampling rate of the stream, according to the source (in Hz).
  ///
  /// If a stream is irregularly sampled, this should be set to #LSL_IRREGULAR_RATE.
  ///
  /// Note that no data will be lost even if this sampling rate is incorrect or if a device has
  /// temporary hiccups, since all samples will be recorded anyway (except for those dropped by the
  /// device itself). However, when the recording is imported into an application, a good importer may
  /// correct such errors more accurately if the advertised sampling rate was close to the specs of the
  /// device.
  double lsl_get_nominal_srate(
    lsl_streaminfo info,
  ) {
    return _lsl_get_nominal_srate(
      info,
    );
  }

  late final _lsl_get_nominal_sratePtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(lsl_streaminfo)>>(
          'lsl_get_nominal_srate');
  late final _lsl_get_nominal_srate =
      _lsl_get_nominal_sratePtr.asFunction<double Function(lsl_streaminfo)>();

  /// Channel format of the stream.
  /// All channels in a stream have the same format.
  /// However, a device might offer multiple time-synched streams  each with its own format.
  lsl_channel_format_t lsl_get_channel_format(
    lsl_streaminfo info,
  ) {
    return lsl_channel_format_t.fromValue(_lsl_get_channel_format(
      info,
    ));
  }

  late final _lsl_get_channel_formatPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(lsl_streaminfo)>>(
          'lsl_get_channel_format');
  late final _lsl_get_channel_format =
      _lsl_get_channel_formatPtr.asFunction<int Function(lsl_streaminfo)>();

  /// Unique identifier of the stream's source, if available.
  ///
  /// The unique source (or device) identifier is an optional piece of information that, if available,
  /// allows that endpoints (such as the recording program) can re-acquire a stream automatically once
  /// it is back online.
  /// @return An immutable library-owned pointer to the string value. @sa lsl_destroy_string()
  ffi.Pointer<ffi.Char> lsl_get_source_id(
    lsl_streaminfo info,
  ) {
    return _lsl_get_source_id(
      info,
    );
  }

  late final _lsl_get_source_idPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(lsl_streaminfo)>>(
      'lsl_get_source_id');
  late final _lsl_get_source_id = _lsl_get_source_idPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(lsl_streaminfo)>();

  /// Protocol version used to deliver the stream.
  int lsl_get_version(
    lsl_streaminfo info,
  ) {
    return _lsl_get_version(
      info,
    );
  }

  late final _lsl_get_versionPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(lsl_streaminfo)>>(
          'lsl_get_version');
  late final _lsl_get_version =
      _lsl_get_versionPtr.asFunction<int Function(lsl_streaminfo)>();

  /// Creation time stamp of the stream.
  ///
  /// This is the time stamp when the stream was first created
  /// (as determined via local_clock() on the providing machine).
  double lsl_get_created_at(
    lsl_streaminfo info,
  ) {
    return _lsl_get_created_at(
      info,
    );
  }

  late final _lsl_get_created_atPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(lsl_streaminfo)>>(
          'lsl_get_created_at');
  late final _lsl_get_created_at =
      _lsl_get_created_atPtr.asFunction<double Function(lsl_streaminfo)>();

  /// Unique ID of the stream outlet (once assigned).
  ///
  /// This is a unique identifier of the stream outlet, and is guaranteed to be different
  /// across multiple instantiations of the same outlet (e.g., after a re-start).
  /// @return An immutable library-owned pointer to the string value. @sa lsl_destroy_string()
  ffi.Pointer<ffi.Char> lsl_get_uid(
    lsl_streaminfo info,
  ) {
    return _lsl_get_uid(
      info,
    );
  }

  late final _lsl_get_uidPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(lsl_streaminfo)>>(
      'lsl_get_uid');
  late final _lsl_get_uid = _lsl_get_uidPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(lsl_streaminfo)>();

  /// Session ID for the given stream.
  ///
  /// The session id is an optional human-assigned identifier of the recording session.
  /// While it is rarely used, it can be used to prevent concurrent recording activitites
  /// on the same sub-network (e.g., in multiple experiment areas) from seeing each other's streams
  /// (assigned via a configuration file by the experimenter, see Network Connectivity on the LSL
  /// wiki).
  /// @return An immutable library-owned pointer to the string value. @sa lsl_destroy_string()
  ffi.Pointer<ffi.Char> lsl_get_session_id(
    lsl_streaminfo info,
  ) {
    return _lsl_get_session_id(
      info,
    );
  }

  late final _lsl_get_session_idPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(lsl_streaminfo)>>(
      'lsl_get_session_id');
  late final _lsl_get_session_id = _lsl_get_session_idPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(lsl_streaminfo)>();

  /// Hostname of the providing machine (once bound to an outlet). Modification is not permitted.
  ffi.Pointer<ffi.Char> lsl_get_hostname(
    lsl_streaminfo info,
  ) {
    return _lsl_get_hostname(
      info,
    );
  }

  late final _lsl_get_hostnamePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(lsl_streaminfo)>>(
      'lsl_get_hostname');
  late final _lsl_get_hostname = _lsl_get_hostnamePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(lsl_streaminfo)>();

  /// Extended description of the stream.
  ///
  /// It is highly recommended that at least the channel labels are described here.
  /// See code examples on the LSL wiki. Other information, such as amplifier settings,
  /// measurement units if deviating from defaults, setup information, subject information, etc.,
  /// can be specified here, as well. Meta-data recommendations follow the XDF file format project
  /// (github.com/sccn/xdf/wiki/Meta-Data or web search for: XDF meta-data).
  ///
  /// @attention if you use a stream content type for which meta-data recommendations exist, please
  /// try to lay out your meta-data in agreement with these recommendations for compatibility with other applications.
  lsl_xml_ptr lsl_get_desc(
    lsl_streaminfo info,
  ) {
    return _lsl_get_desc(
      info,
    );
  }

  late final _lsl_get_descPtr =
      _lookup<ffi.NativeFunction<lsl_xml_ptr Function(lsl_streaminfo)>>(
          'lsl_get_desc');
  late final _lsl_get_desc =
      _lsl_get_descPtr.asFunction<lsl_xml_ptr Function(lsl_streaminfo)>();

  /// Retrieve the entire streaminfo in XML format.
  ///
  /// This yields an XML document (in string form) whose top-level element is `<info>`. The info
  /// element contains one element for each field of the streaminfo class, including:
  ///
  /// - the core elements `<name>`, `<type>`, `<channel_count`, `<nominal_srate>`,
  /// `<channel_format>`, `<source_id>`
  /// - the misc elements `<version>`, `<created_at>`, `<uid>`, `<session_id>`,
  /// `<v4address>`, `<v4data_port>`, `<v4service_port>`, `<v6address>`, `<v6data_port>`,
  /// `<v6service_port>`
  /// - the extended description element `<desc>` with user-defined sub-elements.
  /// @return A pointer to a copy of the XML text or NULL in the event that an error occurred.
  /// @note It is the user's responsibility to deallocate this string when it is no longer needed.
  ffi.Pointer<ffi.Char> lsl_get_xml(
    lsl_streaminfo info,
  ) {
    return _lsl_get_xml(
      info,
    );
  }

  late final _lsl_get_xmlPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(lsl_streaminfo)>>(
      'lsl_get_xml');
  late final _lsl_get_xml = _lsl_get_xmlPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(lsl_streaminfo)>();

  /// Number of bytes occupied by a channel (0 for string-typed channels).
  int lsl_get_channel_bytes(
    lsl_streaminfo info,
  ) {
    return _lsl_get_channel_bytes(
      info,
    );
  }

  late final _lsl_get_channel_bytesPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(lsl_streaminfo)>>(
          'lsl_get_channel_bytes');
  late final _lsl_get_channel_bytes =
      _lsl_get_channel_bytesPtr.asFunction<int Function(lsl_streaminfo)>();

  /// Number of bytes occupied by a sample (0 for string-typed channels).
  int lsl_get_sample_bytes(
    lsl_streaminfo info,
  ) {
    return _lsl_get_sample_bytes(
      info,
    );
  }

  late final _lsl_get_sample_bytesPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(lsl_streaminfo)>>(
          'lsl_get_sample_bytes');
  late final _lsl_get_sample_bytes =
      _lsl_get_sample_bytesPtr.asFunction<int Function(lsl_streaminfo)>();

  /// Tries to match the stream info XML element @p info against an
  /// <a href="https://en.wikipedia.org/wiki/XPath#Syntax_and_semantics_(XPath_1.0)">XPath</a> query.
  ///
  /// Example query strings:
  /// @code
  /// channel_count>5 and type='EEG'
  /// type='TestStream' or contains(name,'Brain')
  /// name='ExampleStream'
  /// @endcode
  int lsl_stream_info_matches_query(
    lsl_streaminfo info,
    ffi.Pointer<ffi.Char> query,
  ) {
    return _lsl_stream_info_matches_query(
      info,
      query,
    );
  }

  late final _lsl_stream_info_matches_queryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(lsl_streaminfo,
              ffi.Pointer<ffi.Char>)>>('lsl_stream_info_matches_query');
  late final _lsl_stream_info_matches_query = _lsl_stream_info_matches_queryPtr
      .asFunction<int Function(lsl_streaminfo, ffi.Pointer<ffi.Char>)>();

  /// Create a streaminfo object from an XML representation
  lsl_streaminfo lsl_streaminfo_from_xml(
    ffi.Pointer<ffi.Char> xml,
  ) {
    return _lsl_streaminfo_from_xml(
      xml,
    );
  }

  late final _lsl_streaminfo_from_xmlPtr = _lookup<
          ffi.NativeFunction<lsl_streaminfo Function(ffi.Pointer<ffi.Char>)>>(
      'lsl_streaminfo_from_xml');
  late final _lsl_streaminfo_from_xml = _lsl_streaminfo_from_xmlPtr
      .asFunction<lsl_streaminfo Function(ffi.Pointer<ffi.Char>)>();

  /// Get the first child of the element.
  lsl_xml_ptr lsl_first_child(
    lsl_xml_ptr e,
  ) {
    return _lsl_first_child(
      e,
    );
  }

  late final _lsl_first_childPtr =
      _lookup<ffi.NativeFunction<lsl_xml_ptr Function(lsl_xml_ptr)>>(
          'lsl_first_child');
  late final _lsl_first_child =
      _lsl_first_childPtr.asFunction<lsl_xml_ptr Function(lsl_xml_ptr)>();

  /// Get the last child of the element.
  lsl_xml_ptr lsl_last_child(
    lsl_xml_ptr e,
  ) {
    return _lsl_last_child(
      e,
    );
  }

  late final _lsl_last_childPtr =
      _lookup<ffi.NativeFunction<lsl_xml_ptr Function(lsl_xml_ptr)>>(
          'lsl_last_child');
  late final _lsl_last_child =
      _lsl_last_childPtr.asFunction<lsl_xml_ptr Function(lsl_xml_ptr)>();

  /// Get the next sibling in the children list of the parent node.
  lsl_xml_ptr lsl_next_sibling(
    lsl_xml_ptr e,
  ) {
    return _lsl_next_sibling(
      e,
    );
  }

  late final _lsl_next_siblingPtr =
      _lookup<ffi.NativeFunction<lsl_xml_ptr Function(lsl_xml_ptr)>>(
          'lsl_next_sibling');
  late final _lsl_next_sibling =
      _lsl_next_siblingPtr.asFunction<lsl_xml_ptr Function(lsl_xml_ptr)>();

  /// Get the previous sibling in the children list of the parent node.
  lsl_xml_ptr lsl_previous_sibling(
    lsl_xml_ptr e,
  ) {
    return _lsl_previous_sibling(
      e,
    );
  }

  late final _lsl_previous_siblingPtr =
      _lookup<ffi.NativeFunction<lsl_xml_ptr Function(lsl_xml_ptr)>>(
          'lsl_previous_sibling');
  late final _lsl_previous_sibling =
      _lsl_previous_siblingPtr.asFunction<lsl_xml_ptr Function(lsl_xml_ptr)>();

  /// Get the parent node.
  lsl_xml_ptr lsl_parent(
    lsl_xml_ptr e,
  ) {
    return _lsl_parent(
      e,
    );
  }

  late final _lsl_parentPtr =
      _lookup<ffi.NativeFunction<lsl_xml_ptr Function(lsl_xml_ptr)>>(
          'lsl_parent');
  late final _lsl_parent =
      _lsl_parentPtr.asFunction<lsl_xml_ptr Function(lsl_xml_ptr)>();

  /// Get a child with a specified name.
  lsl_xml_ptr lsl_child(
    lsl_xml_ptr e,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _lsl_child(
      e,
      name,
    );
  }

  late final _lsl_childPtr = _lookup<
      ffi.NativeFunction<
          lsl_xml_ptr Function(
              lsl_xml_ptr, ffi.Pointer<ffi.Char>)>>('lsl_child');
  late final _lsl_child = _lsl_childPtr
      .asFunction<lsl_xml_ptr Function(lsl_xml_ptr, ffi.Pointer<ffi.Char>)>();

  /// Get the next sibling with the specified name.
  lsl_xml_ptr lsl_next_sibling_n(
    lsl_xml_ptr e,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _lsl_next_sibling_n(
      e,
      name,
    );
  }

  late final _lsl_next_sibling_nPtr = _lookup<
      ffi.NativeFunction<
          lsl_xml_ptr Function(
              lsl_xml_ptr, ffi.Pointer<ffi.Char>)>>('lsl_next_sibling_n');
  late final _lsl_next_sibling_n = _lsl_next_sibling_nPtr
      .asFunction<lsl_xml_ptr Function(lsl_xml_ptr, ffi.Pointer<ffi.Char>)>();

  /// Get the previous sibling with the specified name.
  lsl_xml_ptr lsl_previous_sibling_n(
    lsl_xml_ptr e,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _lsl_previous_sibling_n(
      e,
      name,
    );
  }

  late final _lsl_previous_sibling_nPtr = _lookup<
      ffi.NativeFunction<
          lsl_xml_ptr Function(
              lsl_xml_ptr, ffi.Pointer<ffi.Char>)>>('lsl_previous_sibling_n');
  late final _lsl_previous_sibling_n = _lsl_previous_sibling_nPtr
      .asFunction<lsl_xml_ptr Function(lsl_xml_ptr, ffi.Pointer<ffi.Char>)>();

  /// Whether this node is empty.
  int lsl_empty(
    lsl_xml_ptr e,
  ) {
    return _lsl_empty(
      e,
    );
  }

  late final _lsl_emptyPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(lsl_xml_ptr)>>('lsl_empty');
  late final _lsl_empty = _lsl_emptyPtr.asFunction<int Function(lsl_xml_ptr)>();

  /// Whether this is a text body (instead of an XML element). True both for plain char data and CData.
  int lsl_is_text(
    lsl_xml_ptr e,
  ) {
    return _lsl_is_text(
      e,
    );
  }

  late final _lsl_is_textPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(lsl_xml_ptr)>>(
          'lsl_is_text');
  late final _lsl_is_text =
      _lsl_is_textPtr.asFunction<int Function(lsl_xml_ptr)>();

  /// Name of the element.
  ffi.Pointer<ffi.Char> lsl_name(
    lsl_xml_ptr e,
  ) {
    return _lsl_name(
      e,
    );
  }

  late final _lsl_namePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(lsl_xml_ptr)>>(
          'lsl_name');
  late final _lsl_name =
      _lsl_namePtr.asFunction<ffi.Pointer<ffi.Char> Function(lsl_xml_ptr)>();

  /// Value of the element.
  ffi.Pointer<ffi.Char> lsl_value(
    lsl_xml_ptr e,
  ) {
    return _lsl_value(
      e,
    );
  }

  late final _lsl_valuePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(lsl_xml_ptr)>>(
          'lsl_value');
  late final _lsl_value =
      _lsl_valuePtr.asFunction<ffi.Pointer<ffi.Char> Function(lsl_xml_ptr)>();

  /// Get child value (value of the first child that is text).
  ffi.Pointer<ffi.Char> lsl_child_value(
    lsl_xml_ptr e,
  ) {
    return _lsl_child_value(
      e,
    );
  }

  late final _lsl_child_valuePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(lsl_xml_ptr)>>(
          'lsl_child_value');
  late final _lsl_child_value = _lsl_child_valuePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(lsl_xml_ptr)>();

  /// Get child value of a child with a specified name.
  ffi.Pointer<ffi.Char> lsl_child_value_n(
    lsl_xml_ptr e,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _lsl_child_value_n(
      e,
      name,
    );
  }

  late final _lsl_child_value_nPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              lsl_xml_ptr, ffi.Pointer<ffi.Char>)>>('lsl_child_value_n');
  late final _lsl_child_value_n = _lsl_child_value_nPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(lsl_xml_ptr, ffi.Pointer<ffi.Char>)>();

  /// Append a child node with a given name, which has a (nameless) plain-text child with the given text value.
  lsl_xml_ptr lsl_append_child_value(
    lsl_xml_ptr e,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _lsl_append_child_value(
      e,
      name,
      value,
    );
  }

  late final _lsl_append_child_valuePtr = _lookup<
      ffi.NativeFunction<
          lsl_xml_ptr Function(lsl_xml_ptr, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('lsl_append_child_value');
  late final _lsl_append_child_value = _lsl_append_child_valuePtr.asFunction<
      lsl_xml_ptr Function(
          lsl_xml_ptr, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Prepend a child node with a given name, which has a (nameless) plain-text child with the given text value.
  lsl_xml_ptr lsl_prepend_child_value(
    lsl_xml_ptr e,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _lsl_prepend_child_value(
      e,
      name,
      value,
    );
  }

  late final _lsl_prepend_child_valuePtr = _lookup<
      ffi.NativeFunction<
          lsl_xml_ptr Function(lsl_xml_ptr, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('lsl_prepend_child_value');
  late final _lsl_prepend_child_value = _lsl_prepend_child_valuePtr.asFunction<
      lsl_xml_ptr Function(
          lsl_xml_ptr, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Set the text value of the (nameless) plain-text child of a named child node.
  int lsl_set_child_value(
    lsl_xml_ptr e,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _lsl_set_child_value(
      e,
      name,
      value,
    );
  }

  late final _lsl_set_child_valuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(lsl_xml_ptr, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('lsl_set_child_value');
  late final _lsl_set_child_value = _lsl_set_child_valuePtr.asFunction<
      int Function(
          lsl_xml_ptr, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Set the element's name.
  /// @return 0 if the node is empty (or if out of memory).
  int lsl_set_name(
    lsl_xml_ptr e,
    ffi.Pointer<ffi.Char> rhs,
  ) {
    return _lsl_set_name(
      e,
      rhs,
    );
  }

  late final _lsl_set_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              lsl_xml_ptr, ffi.Pointer<ffi.Char>)>>('lsl_set_name');
  late final _lsl_set_name = _lsl_set_namePtr
      .asFunction<int Function(lsl_xml_ptr, ffi.Pointer<ffi.Char>)>();

  /// Set the element's value.
  /// @return 0 if the node is empty (or if out of memory).
  int lsl_set_value(
    lsl_xml_ptr e,
    ffi.Pointer<ffi.Char> rhs,
  ) {
    return _lsl_set_value(
      e,
      rhs,
    );
  }

  late final _lsl_set_valuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              lsl_xml_ptr, ffi.Pointer<ffi.Char>)>>('lsl_set_value');
  late final _lsl_set_value = _lsl_set_valuePtr
      .asFunction<int Function(lsl_xml_ptr, ffi.Pointer<ffi.Char>)>();

  /// Append a child element with the specified name.
  lsl_xml_ptr lsl_append_child(
    lsl_xml_ptr e,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _lsl_append_child(
      e,
      name,
    );
  }

  late final _lsl_append_childPtr = _lookup<
      ffi.NativeFunction<
          lsl_xml_ptr Function(
              lsl_xml_ptr, ffi.Pointer<ffi.Char>)>>('lsl_append_child');
  late final _lsl_append_child = _lsl_append_childPtr
      .asFunction<lsl_xml_ptr Function(lsl_xml_ptr, ffi.Pointer<ffi.Char>)>();

  /// Prepend a child element with the specified name.
  lsl_xml_ptr lsl_prepend_child(
    lsl_xml_ptr e,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _lsl_prepend_child(
      e,
      name,
    );
  }

  late final _lsl_prepend_childPtr = _lookup<
      ffi.NativeFunction<
          lsl_xml_ptr Function(
              lsl_xml_ptr, ffi.Pointer<ffi.Char>)>>('lsl_prepend_child');
  late final _lsl_prepend_child = _lsl_prepend_childPtr
      .asFunction<lsl_xml_ptr Function(lsl_xml_ptr, ffi.Pointer<ffi.Char>)>();

  /// Append a copy of the specified element as a child.
  lsl_xml_ptr lsl_append_copy(
    lsl_xml_ptr e,
    lsl_xml_ptr e2,
  ) {
    return _lsl_append_copy(
      e,
      e2,
    );
  }

  late final _lsl_append_copyPtr = _lookup<
          ffi.NativeFunction<lsl_xml_ptr Function(lsl_xml_ptr, lsl_xml_ptr)>>(
      'lsl_append_copy');
  late final _lsl_append_copy = _lsl_append_copyPtr
      .asFunction<lsl_xml_ptr Function(lsl_xml_ptr, lsl_xml_ptr)>();

  /// Prepend a child element with the specified name.
  lsl_xml_ptr lsl_prepend_copy(
    lsl_xml_ptr e,
    lsl_xml_ptr e2,
  ) {
    return _lsl_prepend_copy(
      e,
      e2,
    );
  }

  late final _lsl_prepend_copyPtr = _lookup<
          ffi.NativeFunction<lsl_xml_ptr Function(lsl_xml_ptr, lsl_xml_ptr)>>(
      'lsl_prepend_copy');
  late final _lsl_prepend_copy = _lsl_prepend_copyPtr
      .asFunction<lsl_xml_ptr Function(lsl_xml_ptr, lsl_xml_ptr)>();

  /// Remove a child element with the specified name.
  void lsl_remove_child_n(
    lsl_xml_ptr e,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _lsl_remove_child_n(
      e,
      name,
    );
  }

  late final _lsl_remove_child_nPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              lsl_xml_ptr, ffi.Pointer<ffi.Char>)>>('lsl_remove_child_n');
  late final _lsl_remove_child_n = _lsl_remove_child_nPtr
      .asFunction<void Function(lsl_xml_ptr, ffi.Pointer<ffi.Char>)>();

  /// Remove a specified child element.
  void lsl_remove_child(
    lsl_xml_ptr e,
    lsl_xml_ptr e2,
  ) {
    return _lsl_remove_child(
      e,
      e2,
    );
  }

  late final _lsl_remove_childPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(lsl_xml_ptr, lsl_xml_ptr)>>(
          'lsl_remove_child');
  late final _lsl_remove_child = _lsl_remove_childPtr
      .asFunction<void Function(lsl_xml_ptr, lsl_xml_ptr)>();

  /// Construct a new #lsl_continuous_resolver that resolves all streams on the network.
  ///
  /// This is analogous to the functionality offered by the free function lsl_resolve_streams().
  /// @param forget_after When a stream is no longer visible on the network (e.g. because it was shut
  /// down), this is the time in seconds after which it is no longer reported by the resolver.
  ///
  /// The recommended default value is 5.0.
  lsl_continuous_resolver lsl_create_continuous_resolver(
    double forget_after,
  ) {
    return _lsl_create_continuous_resolver(
      forget_after,
    );
  }

  late final _lsl_create_continuous_resolverPtr =
      _lookup<ffi.NativeFunction<lsl_continuous_resolver Function(ffi.Double)>>(
          'lsl_create_continuous_resolver');
  late final _lsl_create_continuous_resolver =
      _lsl_create_continuous_resolverPtr
          .asFunction<lsl_continuous_resolver Function(double)>();

  /// Construct a new lsl_continuous_resolver that resolves all streams with a specific value for a given
  /// property.
  ///
  /// This is analogous to the functionality provided by the free function lsl_resolve_byprop()
  /// @param prop The #lsl_streaminfo property that should have a specific value (e.g., "name", "type",
  /// "source_id", or "desc/manufaturer").
  /// @param value The string value that the property should have (e.g., "EEG" as the type property).
  /// @param forget_after When a stream is no longer visible on the network (e.g., because it was shut
  /// down), this is the time in seconds after which it is no longer reported by the resolver.
  /// The recommended default value is 5.0.
  lsl_continuous_resolver lsl_create_continuous_resolver_byprop(
    ffi.Pointer<ffi.Char> prop,
    ffi.Pointer<ffi.Char> value,
    double forget_after,
  ) {
    return _lsl_create_continuous_resolver_byprop(
      prop,
      value,
      forget_after,
    );
  }

  late final _lsl_create_continuous_resolver_bypropPtr = _lookup<
      ffi.NativeFunction<
          lsl_continuous_resolver Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Double)>>('lsl_create_continuous_resolver_byprop');
  late final _lsl_create_continuous_resolver_byprop =
      _lsl_create_continuous_resolver_bypropPtr.asFunction<
          lsl_continuous_resolver Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, double)>();

  /// Construct a new lsl_continuous_resolver that resolves all streams that match a given XPath 1.0
  /// predicate.
  ///
  /// This is analogous to the functionality provided by the free function lsl_resolve_bypred()
  /// @param pred The predicate string, e.g.
  /// `"name='BioSemi'" or "type='EEG' and starts-with(name,'BioSemi') and count(info/desc/channel)=32"`
  /// @param forget_after When a stream is no longer visible on the network (e.g., because it was shut
  /// down), this is the time in seconds after which it is no longer reported by the resolver.
  /// The recommended default value is 5.0.
  lsl_continuous_resolver lsl_create_continuous_resolver_bypred(
    ffi.Pointer<ffi.Char> pred,
    double forget_after,
  ) {
    return _lsl_create_continuous_resolver_bypred(
      pred,
      forget_after,
    );
  }

  late final _lsl_create_continuous_resolver_bypredPtr = _lookup<
      ffi.NativeFunction<
          lsl_continuous_resolver Function(ffi.Pointer<ffi.Char>,
              ffi.Double)>>('lsl_create_continuous_resolver_bypred');
  late final _lsl_create_continuous_resolver_bypred =
      _lsl_create_continuous_resolver_bypredPtr.asFunction<
          lsl_continuous_resolver Function(ffi.Pointer<ffi.Char>, double)>();

  /// Obtain the set of currently present streams on the network (i.e. resolve result).
  ///
  /// @param res A continuous resolver (previously created with one of the
  /// lsl_create_continuous_resolver() functions).
  /// @param buffer A user-allocated buffer to hold the current resolve results.<br>
  /// @attention It is the user's responsibility to either destroy the resulting streaminfo objects or
  /// to pass them back to the LSL during during creation of an inlet.
  /// @attention The stream_infos returned by the resolver are only short versions that do not include
  /// the lsl_get_desc() field (which can be arbitrarily big).
  ///
  /// To obtain the full stream information you need to call lsl_get_info() on the inlet after you have
  /// created one.
  /// @param buffer_elements The user-provided buffer length.
  /// @return The number of results written into the buffer (never more than the provided # of slots)
  /// or a negative number if an error has occurred (values corresponding to #lsl_error_code_t).
  int lsl_resolver_results(
    lsl_continuous_resolver res,
    ffi.Pointer<lsl_streaminfo> buffer,
    int buffer_elements,
  ) {
    return _lsl_resolver_results(
      res,
      buffer,
      buffer_elements,
    );
  }

  late final _lsl_resolver_resultsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              lsl_continuous_resolver,
              ffi.Pointer<lsl_streaminfo>,
              ffi.Uint32)>>('lsl_resolver_results');
  late final _lsl_resolver_results = _lsl_resolver_resultsPtr.asFunction<
      int Function(
          lsl_continuous_resolver, ffi.Pointer<lsl_streaminfo>, int)>();

  /// Destructor for the continuous resolver.
  void lsl_destroy_continuous_resolver(
    lsl_continuous_resolver res,
  ) {
    return _lsl_destroy_continuous_resolver(
      res,
    );
  }

  late final _lsl_destroy_continuous_resolverPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(lsl_continuous_resolver)>>(
          'lsl_destroy_continuous_resolver');
  late final _lsl_destroy_continuous_resolver =
      _lsl_destroy_continuous_resolverPtr
          .asFunction<void Function(lsl_continuous_resolver)>();

  /// Resolve all streams on the network.
  ///
  /// This function returns all currently available streams from any outlet on the network.
  /// The network is usually the subnet specified at the local router, but may also include a multicast
  /// group of machines (given that the network supports it), or a list of hostnames.<br>
  /// These details may optionally be customized by the experimenter in a configuration file
  /// (see page Network Connectivity in the LSL wiki).
  /// This is the default mechanism used by the browsing programs and the recording program.
  /// @param[out] buffer A user-allocated buffer to hold the resolve results.
  /// @attention It is the user's responsibility to either destroy the resulting streaminfo objects or
  /// to pass them back to the LSL during during creation of an inlet.
  ///
  /// @attention The stream_info's returned by the resolver are only short versions that do not include
  /// the lsl_get_desc() field (which can be arbitrarily big).
  /// To obtain the full stream information you need to call lsl_get_info() on the inlet after you have
  /// created one.
  /// @param buffer_elements The user-provided buffer length.
  /// @param wait_time The waiting time for the operation, in seconds, to search for streams.
  /// The recommended wait time is 1 second (or 2 for a busy and large recording operation).
  /// @warning If this is too short (<0.5s) only a subset (or none) of the outlets that are present on
  /// the network may be returned.
  /// @return The number of results written into the buffer (never more than the provided # of slots)
  /// or a negative number if an error has occurred (values corresponding to lsl_error_code_t).
  int lsl_resolve_all(
    ffi.Pointer<lsl_streaminfo> buffer,
    int buffer_elements,
    double wait_time,
  ) {
    return _lsl_resolve_all(
      buffer,
      buffer_elements,
      wait_time,
    );
  }

  late final _lsl_resolve_allPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<lsl_streaminfo>, ffi.Uint32,
              ffi.Double)>>('lsl_resolve_all');
  late final _lsl_resolve_all = _lsl_resolve_allPtr
      .asFunction<int Function(ffi.Pointer<lsl_streaminfo>, int, double)>();

  /// Resolve all streams with a given value for a property.
  ///
  /// If the goal is to resolve a specific stream, this method is preferred over resolving all streams
  /// and then selecting the desired one.
  /// @param[out] buffer A user-allocated buffer to hold the resolve results.
  /// @attention It is the user's responsibility to either destroy the resulting streaminfo objects or
  /// to pass them back to the LSL during during creation of an inlet.
  ///
  /// @attention The stream_info's returned by the resolver are only short versions that do not include
  /// the lsl_get_desc() field (which can be arbitrarily big). To obtain the full stream information
  /// you need to call lsl_get_info() on the inlet after you have created one.
  /// @param buffer_elements The user-provided buffer length.
  /// @param prop The streaminfo property that should have a specific value (`"name"`, `"type"`,
  /// `"source_id"`, or, e.g., `"desc/manufaturer"` if present).
  /// @param value The string value that the property should have (e.g., "EEG" as the type).
  /// @param minimum Return at least this number of streams.
  /// @param timeout Optionally a timeout of the operation, in seconds (default: no timeout).
  /// If the timeout expires, less than the desired number of streams (possibly none) will be returned.
  /// @return The number of results written into the buffer (never more than the provided # of slots)
  /// or a negative number if an error has occurred (values corresponding to #lsl_error_code_t).
  int lsl_resolve_byprop(
    ffi.Pointer<lsl_streaminfo> buffer,
    int buffer_elements,
    ffi.Pointer<ffi.Char> prop,
    ffi.Pointer<ffi.Char> value,
    int minimum,
    double timeout,
  ) {
    return _lsl_resolve_byprop(
      buffer,
      buffer_elements,
      prop,
      value,
      minimum,
      timeout,
    );
  }

  late final _lsl_resolve_bypropPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<lsl_streaminfo>,
              ffi.Uint32,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Int32,
              ffi.Double)>>('lsl_resolve_byprop');
  late final _lsl_resolve_byprop = _lsl_resolve_bypropPtr.asFunction<
      int Function(ffi.Pointer<lsl_streaminfo>, int, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, int, double)>();

  /// Resolve all streams that match a given predicate.
  ///
  /// Advanced query that allows to impose more conditions on the retrieved streams;
  /// the given string is an [XPath 1.0 predicate](http://en.wikipedia.org/w/index.php?title=XPath_1.0)
  /// for the `<info>` node (omitting the surrounding []'s)
  /// @param[out] buffer A user-allocated buffer to hold the resolve results.
  /// @attention It is the user's responsibility to either destroy the resulting streaminfo objects or
  /// to pass them back to the LSL during during creation of an inlet.
  ///
  /// @attention The stream_info's returned by the resolver are only short versions that do not include
  /// the lsl_get_desc() field (which can be arbitrarily big). To obtain the full stream information
  /// you need to call lsl_get_info() on the inlet after you have created one.
  /// @param buffer_elements The user-provided buffer length.
  /// @param pred The predicate string, e.g.
  /// `name='BioSemi'` or `type='EEG' and starts-with(name,'BioSemi') and count(info/desc/channel)=32`
  /// @param minimum Return at least this number of streams.
  /// @param timeout Optionally a timeout of the operation, in seconds (default: no timeout).
  /// If the timeout expires, less than the desired number of streams (possibly none)
  /// will be returned.
  /// @return The number of results written into the buffer (never more than the provided # of slots)
  /// or a negative number if an error has occurred (values corresponding to lsl_error_code_t).
  int lsl_resolve_bypred(
    ffi.Pointer<lsl_streaminfo> buffer,
    int buffer_elements,
    ffi.Pointer<ffi.Char> pred,
    int minimum,
    double timeout,
  ) {
    return _lsl_resolve_bypred(
      buffer,
      buffer_elements,
      pred,
      minimum,
      timeout,
    );
  }

  late final _lsl_resolve_bypredPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<lsl_streaminfo>,
              ffi.Uint32,
              ffi.Pointer<ffi.Char>,
              ffi.Int32,
              ffi.Double)>>('lsl_resolve_bypred');
  late final _lsl_resolve_bypred = _lsl_resolve_bypredPtr.asFunction<
      int Function(ffi.Pointer<lsl_streaminfo>, int, ffi.Pointer<ffi.Char>, int,
          double)>();
}

final class lsl_streaminfo_struct_ extends ffi.Opaque {}

final class lsl_outlet_struct_ extends ffi.Opaque {}

final class lsl_inlet_struct_ extends ffi.Opaque {}

final class lsl_xml_ptr_struct_ extends ffi.Opaque {}

final class lsl_continuous_resolver_ extends ffi.Opaque {}

/// @class lsl_outlet
/// A stream outlet handle.
/// Outlets are used to make streaming data (and the meta-data) available on the lab network.
typedef lsl_outlet = ffi.Pointer<lsl_outlet_struct_>;

/// @class lsl_streaminfo
/// Handle to a stream info object.
///
/// Stores the declaration of a data stream.
/// Represents the following information:
///
/// - stream data format (number of channels, channel format)
/// - core information (stream name, content type, sampling rate)
/// - optional meta-data about the stream content (channel labels, measurement units, etc.)
///
/// Whenever a program wants to provide a new stream on the lab network it will typically first
/// create an lsl_streaminfo to describe its properties and then construct an #lsl_outlet with it to
/// create the stream on the network. Other parties who discover/resolve the outlet on the network
/// can query the stream info; it is also written to disk when recording the stream (playing a
/// similar role as a file header).
typedef lsl_streaminfo = ffi.Pointer<lsl_streaminfo_struct_>;

/// Flags for outlet_ex and inlet_ex
enum lsl_transport_options_t {
  /// Keep legacy behavior: max_buffered / max_buflen is in seconds; use asynch transfer.
  transp_default(0),

  /// The supplied max_buf value is in samples.
  transp_bufsize_samples(1),

  /// The supplied max_buf should be scaled by 0.001.
  transp_bufsize_thousandths(2),

  /// prevent compilers from assuming an instance fits in a single byte
  _lsl_transport_options_maxval(2130706432);

  final int value;
  const lsl_transport_options_t(this.value);

  static lsl_transport_options_t fromValue(int value) => switch (value) {
        0 => transp_default,
        1 => transp_bufsize_samples,
        2 => transp_bufsize_thousandths,
        2130706432 => _lsl_transport_options_maxval,
        _ => throw ArgumentError(
            "Unknown value for lsl_transport_options_t: $value"),
      };
}

/// Data format of a channel (each transmitted sample holds an array of channels), 4 bytes wide
enum lsl_channel_format_t {
  /// For up to 24-bit precision measurements in the appropriate physical unit (e.g., microvolts).
  /// Integers from -16777216 to 16777216 are represented accurately.
  cft_float32(1),

  /// For universal numeric data as long as permitted by network & disk budget.
  /// The largest representable integer is 53-bit.
  cft_double64(2),

  /// For variable-length ASCII strings or data blobs, such as video frames, complex event
  /// descriptions, etc.
  cft_string(3),

  /// For high-rate digitized formats that require 32-bit precision.
  /// Depends critically on meta-data to represent meaningful units.
  /// Useful for application event codes or other coded data.
  cft_int32(4),

  /// For very high rate signals (40Khz+) or consumer-grade audio.
  /// For professional audio float is recommended.
  cft_int16(5),

  /// For binary signals or other coded data. Not recommended for encoding string data.
  cft_int8(6),

  /// 64 bit integers. Support for this type is not yet exposed in all languages.
  /// Also, some builds of liblsl will not be able to send or receive data of this type.
  cft_int64(7),

  /// Can not be transmitted.
  cft_undefined(0),

  /// prevent compilers from assuming an instance fits in a single byte
  _cft_maxval(2130706432);

  final int value;
  const lsl_channel_format_t(this.value);

  static lsl_channel_format_t fromValue(int value) => switch (value) {
        1 => cft_float32,
        2 => cft_double64,
        3 => cft_string,
        4 => cft_int32,
        5 => cft_int16,
        6 => cft_int8,
        7 => cft_int64,
        0 => cft_undefined,
        2130706432 => _cft_maxval,
        _ =>
          throw ArgumentError("Unknown value for lsl_channel_format_t: $value"),
      };
}

/// Post-processing options for stream inlets.
enum lsl_processing_options_t {
  /// No automatic post-processing; return the ground-truth time stamps for manual
  /// post-processing. This is the default behavior of the inlet.
  proc_none(0),

  /// Perform automatic clock synchronization; equivalent to manually adding the time_correction()
  /// value to the received time stamps.
  proc_clocksync(1),

  /// Remove jitter from time stamps.
  ///
  /// This will apply a smoothing algorithm to the received time stamps; the smoothing needs to see
  /// a minimum number of samples (30-120 seconds worst-case) until the remaining jitter is
  /// consistently below 1ms.
  proc_dejitter(2),

  /// Force the time-stamps to be monotonically ascending.
  ///
  /// Only makes sense if timestamps are dejittered.
  proc_monotonize(4),

  /// Post-processing is thread-safe (same inlet can be read from by multiple threads);
  /// uses somewhat more CPU.
  proc_threadsafe(8),

  /// The combination of all possible post-processing options.
  proc_ALL(15),

  /// prevent compilers from assuming an instance fits in a single byte
  _proc_maxval(2130706432);

  final int value;
  const lsl_processing_options_t(this.value);

  static lsl_processing_options_t fromValue(int value) => switch (value) {
        0 => proc_none,
        1 => proc_clocksync,
        2 => proc_dejitter,
        4 => proc_monotonize,
        8 => proc_threadsafe,
        15 => proc_ALL,
        2130706432 => _proc_maxval,
        _ => throw ArgumentError(
            "Unknown value for lsl_processing_options_t: $value"),
      };
}

/// Possible error codes.
enum lsl_error_code_t {
  /// No error occurred
  lsl_no_error(0),

  /// The operation failed due to a timeout.
  lsl_timeout_error(-1),

  /// The stream has been lost.
  lsl_lost_error(-2),

  /// An argument was incorrectly specified (e.g., wrong format or wrong length).
  lsl_argument_error(-3),

  /// Some other internal error has happened.
  lsl_internal_error(-4),

  /// prevent compilers from assuming an instance fits in a single byte
  _lsl_error_code_maxval(2130706432);

  final int value;
  const lsl_error_code_t(this.value);

  static lsl_error_code_t fromValue(int value) => switch (value) {
        0 => lsl_no_error,
        -1 => lsl_timeout_error,
        -2 => lsl_lost_error,
        -3 => lsl_argument_error,
        -4 => lsl_internal_error,
        2130706432 => _lsl_error_code_maxval,
        _ => throw ArgumentError("Unknown value for lsl_error_code_t: $value"),
      };
}

/// @class lsl_inlet
/// A stream inlet handle.
/// Inlets are used to receive streaming data (and meta-data) from the lab network.
typedef lsl_inlet = ffi.Pointer<lsl_inlet_struct_>;

/// @class lsl_xml_ptr
/// A lightweight XML element tree handle; models the description of a streaminfo object.
/// XML elements behave like advanced pointers into memory that is owned by some respective
/// streaminfo.
/// Has a name and can have multiple named children or have text content as value;
/// attributes are omitted.
/// @note The interface is modeled after a subset of pugixml's node type and is compatible with it.
/// Type-casts between pugi::xml_node_struct* and #lsl_xml_ptr are permitted (in both directions)
/// since the types are binary compatible.
/// @sa [pugixml documentation](https://pugixml.org/docs/manual.html#access).
typedef lsl_xml_ptr = ffi.Pointer<lsl_xml_ptr_struct_>;

/// @class lsl_continuous_resolver
///
/// Handle to a convenience object that resolves streams continuously in the background throughout
/// its lifetime and which can be queried at any time for the set of streams that are currently
/// visible on the network.
typedef lsl_continuous_resolver = ffi.Pointer<lsl_continuous_resolver_>;

const double LSL_IRREGULAR_RATE = 0.0;

const double LSL_DEDUCED_TIMESTAMP = -1.0;

const double LSL_FOREVER = 32000000.0;

const int LSL_NO_PREFERENCE = 0;

const int LIBLSL_COMPILE_HEADER_VERSION = 114;
