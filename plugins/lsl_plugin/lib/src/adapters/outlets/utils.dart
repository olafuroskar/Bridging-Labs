import 'dart:ffi';

import 'package:ffi/ffi.dart';
import 'package:lsl_plugin/lsl_plugin.dart';
import 'package:lsl_plugin/src/channel_formats/channel_format.dart';
import 'package:lsl_plugin/src/liblsl.dart';
import 'package:lsl_plugin/src/lsl_bindings_generated.dart';
import 'package:lsl_plugin/src/utils/errors.dart';
import 'package:lsl_plugin/src/utils/unit.dart';

Result<lsl_outlet> createOutlet<S>(
    Outlet<S> outlet, ChannelFormat<S> channelFormat) {
  try {
    // Required on Android, TODO: Explain more...
    lsl.multicastLock.acquire();

    final streamInfo = lsl.bindings.lsl_create_streaminfo(
        outlet.streamInfo.name.toNativeUtf8().cast<Char>(),
        outlet.streamInfo.type.toNativeUtf8().cast<Char>(),
        outlet.streamInfo.channelCount,
        outlet.streamInfo.nominalSRate,
        channelFormat.nativeChannelFormat,
        outlet.streamInfo.sourceId.toNativeUtf8().cast<Char>());

    return Result.ok(lsl.bindings
        .lsl_create_outlet(streamInfo, outlet.chunkSize, outlet.maxBuffered));
  } catch (e) {
    return unexpectedError("$e");
  }
}

Result<Unit> destroyOutlet(lsl_outlet? outlet) {
  if (outlet == null) {
    return Result.error(Exception("The native outlet is null"));
  }
  try {
    lsl.bindings.lsl_destroy_outlet(outlet);
    lsl.multicastLock.release();
    return Result.ok(unit);
  } catch (e) {
    return unexpectedError("$e");
  }
}

/// "Unwraps" the nullable native outlet
///
/// {@template non_null_members}
/// The Dart compiler can only infer that variables are not null on local variables
/// so null checks on member variable in e.g. the reHH
/// {@endtemplate}
lsl_outlet getOutlet(lsl_outlet? outlet) {
  if (outlet == null) {
    throw Exception("The native outlet is null");
  }
  return outlet;
}

ChannelFormat getChannelFormat(lsl_channel_format_t channelFormat) {
  switch (channelFormat) {
    case lsl_channel_format_t.cft_int8:
      return Int8ChannelFormat();
    case lsl_channel_format_t.cft_int16:
      return Int16ChannelFormat();
    case lsl_channel_format_t.cft_int32:
      return Int32ChannelFormat();
    case lsl_channel_format_t.cft_int64:
      return Int64ChannelFormat();
    case lsl_channel_format_t.cft_double64:
      return Double64ChannelFormat();
    case lsl_channel_format_t.cft_float32:
      return Float32ChannelFormat();
    case lsl_channel_format_t.cft_string:
      return CftStringChannelFormat();
    default:
      throw Exception("Unsupported channel format");
  }
}

Result<StreamInfo> getStreamInfo(lsl_outlet? outlet) {
  try {
    final nativeInfo = lsl.bindings.lsl_get_info(getOutlet(outlet));

    // User defined
    final name = lsl.bindings.lsl_get_name(nativeInfo);
    final type = lsl.bindings.lsl_get_type(nativeInfo);
    final channelCount = lsl.bindings.lsl_get_channel_count(nativeInfo);
    final nominalSrate = lsl.bindings.lsl_get_nominal_srate(nativeInfo);
    final channelFormat = lsl.bindings.lsl_get_channel_format(nativeInfo);
    final sourceId = lsl.bindings.lsl_get_source_id(nativeInfo);

    // Generated by LSL
    final version = lsl.bindings.lsl_get_version(nativeInfo);
    final createdAt = lsl.bindings.lsl_get_created_at(nativeInfo);
    final uid = lsl.bindings.lsl_get_uid(nativeInfo);
    final sessionId = lsl.bindings.lsl_get_session_id(nativeInfo);
    final hostname = lsl.bindings.lsl_get_hostname(nativeInfo);

    final streamInfo = StreamInfo(
        name.cast<Utf8>().toDartString(),
        type.cast<Utf8>().toDartString(),
        getChannelFormat(channelFormat),
        channelCount,
        nominalSrate,
        sourceId.cast<Utf8>().toDartString());

    streamInfo.version = version;
    streamInfo.createdAt = createdAt;
    streamInfo.uid = uid.cast<Utf8>().toDartString();
    streamInfo.sessionId = sessionId.cast<Utf8>().toDartString();
    streamInfo.hostname = hostname.cast<Utf8>().toDartString();

    return Result.ok(streamInfo);
  } catch (e) {
    return unexpectedError("$e");
  }
}
